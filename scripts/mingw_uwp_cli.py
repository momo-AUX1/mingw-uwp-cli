#!/usr/bin/env python3
import argparse
import shutil
import uuid
import tempfile
import os
import subprocess
import base64
import ssl
import urllib.request
import urllib.error
import urllib.parse
import webbrowser
import threading
import socket
import http.client
from pathlib import Path
import re
import json
import sys
from typing import Optional
from xml.etree import ElementTree as ET

try:
    from PIL import Image
except Exception:
    Image = None

TEXT_EXTENSIONS = {'.txt', '.in', '.xml', '.xaml', '.cpp', '.h', '.hpp', '.c', '.cmake', 'CMakeLists.txt', '.md'}
DEFAULT_CONFIG_NAME = 'mingw_winrt.json'
ARCH_CHOICES = ('x64', 'x86', 'arm64', 'arm')
MSVC_DLLS = (
    'msvcp140_app.dll',
    'vcruntime140_app.dll',
    'vcruntime140_1_app.dll',
    'dxil.dll',
    'vccorlib140_app.dll'
)
WINDOWS = os.name == 'nt'
RUN_ALIASES = {'run', 'install', 'runner', 'installer', 'deploy'}
DEVICE_PORTAL_KEY = 'devicePortal'
REPO_ROOT = Path(__file__).parent.parent
TOOL_DB_PATH = Path(__file__).with_name("db.json")
NAMESPACE_URIS = {
    'foundation': 'http://schemas.microsoft.com/appx/manifest/foundation/windows10',
    'uap': 'http://schemas.microsoft.com/appx/manifest/uap/windows10',
    'rescap': 'http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities',
}
CAPABILITY_DEFS = {
    'internetClient': 'foundation',
    'internetClientServer': 'foundation',
    'privateNetworkClientServer': 'foundation',
    'enterpriseAuthentication': 'foundation',
    'sharedUserCertificates': 'foundation',
    'removableStorage': 'uap',
    'documentsLibrary': 'uap',
    'picturesLibrary': 'uap',
    'videosLibrary': 'uap',
    'musicLibrary': 'uap',
    'location': 'uap',
    'microphone': 'uap',
    'webcam': 'uap',
    'userAccountInformation': 'uap',
    'contacts': 'uap',
    'appointments': 'uap',
    'codeGeneration': 'rescap',
    'broadFileSystemAccess': 'rescap',
    'runFullTrust': 'rescap',
}
STANDARD_CAPS = (
    'internetClient',
    'internetClientServer',
    'privateNetworkClientServer',
    'removableStorage',
    'documentsLibrary',
    'picturesLibrary',
    'videosLibrary',
    'musicLibrary',
    'location',
    'microphone',
    'webcam',
)
RESTRICTED_CAPS = (
    'codeGeneration',
    'broadFileSystemAccess',
    'runFullTrust',
)
OPTIONAL_CAPS = (
    'enterpriseAuthentication',
    'sharedUserCertificates',
    'userAccountInformation',
    'contacts',
    'appointments',
)

def _supports_color() -> bool:
    if not sys.stdout.isatty():
        return False
    term = os.environ.get('TERM', '')
    return term != 'dumb'

def _color(text: str, code: str) -> str:
    if not _supports_color():
        return text
    return f"\033[{code}m{text}\033[0m"

def _info(text: str) -> None:
    print(_color(text, '36'))

def _success(text: str) -> None:
    print(_color(text, '32'))

def _warn(text: str) -> None:
    print(_color(text, '33'))

def _error(text: str) -> None:
    print(_color(text, '31'))

def sanitize_namespace(name: str) -> str:
    s = re.sub(r'[^0-9A-Za-z_]', '', name)
    if not s:
        return 'App'
    if s[0].isdigit():
        s = '_' + s
    return s

def is_text_file(path: Path) -> bool:
    ext = path.suffix
    if path.name == 'CMakeLists.txt':
        return True
    return ext in TEXT_EXTENSIONS

def replace_in_file(path: Path, replacements):
    try:
        text = path.read_text(encoding='utf-8')
    except Exception:
        return
    original = text
    for old, new in replacements.items():
        text = text.replace(old, new)
    guid_regex = re.compile(r'[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}')
    def guid_replacer(match):
        return str(uuid.uuid4())
    text = guid_regex.sub(guid_replacer, text)
    if text != original:
        path.write_text(text, encoding='utf-8')

def _write_project_readme(out_dir: Path, project_name: str, project_type: str) -> None:
    extra_install = ""
    if project_type in ('xaml', 'corewindow'):
        extra_install = "\nFast register (dev loop):\n\n```powershell\n" \
                        "powershell.exe -Command Add-AppxPackage -Register .\\AppxManifest.xml\n" \
                        "```\n"

    readme = f"""# {project_name}

Generated by the MinGW WinRT project generator.

## Build

```powershell
cmake -S . -B build
cmake --build build
```

## Package (Appx/MSIX)

```powershell
cmake --build build --target appx
cmake --build build --target msix
```

Outputs will be in `build/{project_name}.appx` or `build/{project_name}.msix`.

## Install

```powershell
powershell.exe -NoProfile -ExecutionPolicy Bypass -File .\install.ps1 -Package .\ build\{project_name}.appx
```

If you have the Windows 10/11 SDK installed, `makeappx.exe` is used for packaging.
{extra_install}

## Troubleshooting (macOS/Linux cross-build)

If you build with MinGW GCC 15 on macOS/Linux and see a coroutine_handle error in WinRT headers, reconfigure with:

```powershell
cmake -S . -B build -DMINGW_WINRT_COROUTINE_ALIAS_FIX=ON
```

This applies a build-directory-only workaround. Windows builds do not need it.
"""
    (out_dir / 'README.md').write_text(readme, encoding='utf-8')

def _write_install_script(out_dir: Path, project_name: str) -> None:
    script = f"""param(
    [string]$Package = ""
)

$ErrorActionPreference = "Stop"

if (-not $Package) {{
    if (Test-Path ".\build\{project_name}.msix") {{
        $Package = ".\build\{project_name}.msix"
    }} elseif (Test-Path ".\build\{project_name}.appx") {{
        $Package = ".\build\{project_name}.appx"
    }} else {{
        Write-Host "Package not found. Build and package first." -ForegroundColor Red
        exit 1
    }}
}}

Write-Host "Installing $Package" -ForegroundColor Cyan
Add-AppxPackage -Path $Package
"""
    (out_dir / 'install.ps1').write_text(script, encoding='utf-8')

def _ensure_deps_layout(out_dir: Path) -> None:
    for sub in ('bin', 'include', 'lib'):
        (out_dir / 'deps' / sub).mkdir(parents=True, exist_ok=True)

def _arch_folder(arch: str) -> str:
    return {
        'x64': 'x64',
        'x86': 'x86',
        'arm64': 'arm64',
        'arm': 'arm',
    }.get(arch, arch)

def _find_msvc_redist_dir(arch: str) -> Optional[Path]:
    repo_msvc = REPO_ROOT / 'MSVC'
    if repo_msvc.exists():
        return repo_msvc
    return None

def _copy_msvc_dlls(out_dir: Path, arch: str) -> None:
    redist_dir = _find_msvc_redist_dir(arch)
    if not redist_dir:
        _warn("‚ö†Ô∏è  MSVC redist not found; skipping MSVC DLL copy.")
        return
    dest = out_dir / 'deps' / 'bin'
    dest.mkdir(parents=True, exist_ok=True)
    any_copied = False
    for dll in MSVC_DLLS:
        src = redist_dir / dll
        if src.exists():
            shutil.copy2(src, dest / dll)
            any_copied = True
        else:
            _warn(f"‚ö†Ô∏è  Missing MSVC DLL: {src}")
    if not any_copied:
        _warn(f"‚ö†Ô∏è  No specified MSVC DLLs were found in {redist_dir}; nothing was copied.")

def _get_manifest_paths(project_dir: Path) -> list:
    paths = []
    for name in ('AppxManifest.in', 'AppxManifest.xml'):
        path = project_dir / name
        if path.exists():
            paths.append(path)
    return paths

def _local_name(tag: str) -> str:
    if tag.startswith('{'):
        return tag.split('}', 1)[1]
    return tag

def _root_namespace(tag: str) -> str:
    if tag.startswith('{'):
        return tag.split('}', 1)[0].strip('{')
    return ''

def _read_manifest_capabilities(path: Path) -> set:
    try:
        tree = ET.parse(path)
    except Exception:
        return set()
    root = tree.getroot()
    caps = set()
    for elem in root.iter():
        if _local_name(elem.tag) != 'Capability':
            continue
        name = elem.attrib.get('Name')
        if name:
            caps.add(name)
    return caps

def _ensure_ignorable_namespaces(root: ET.Element, prefixes: set) -> None:
    existing = root.attrib.get('IgnorableNamespaces', '')
    current = [p for p in existing.split(' ') if p]
    merged = set(current) | set(prefixes)
    if merged:
        root.set('IgnorableNamespaces', ' '.join(sorted(merged)))

def _update_manifest_capabilities_file(path: Path, selected_caps: set) -> None:
    try:
        tree = ET.parse(path)
    except Exception:
        return

    root = tree.getroot()
    foundation_ns = _root_namespace(root.tag) or NAMESPACE_URIS['foundation']

    ET.register_namespace('', foundation_ns)
    ET.register_namespace('uap', NAMESPACE_URIS['uap'])
    ET.register_namespace('rescap', NAMESPACE_URIS['rescap'])

    caps_parent = None
    for child in list(root):
        if _local_name(child.tag) == 'Capabilities':
            caps_parent = child
            break
    if caps_parent is None:
        caps_parent = ET.Element(f"{{{foundation_ns}}}Capabilities")
        root.append(caps_parent)

    known_caps = set(CAPABILITY_DEFS.keys())
    existing_caps = set()

    for parent in root.iter():
        for child in list(parent):
            if _local_name(child.tag) != 'Capability':
                continue
            cap_name = child.attrib.get('Name')
            if not cap_name:
                continue
            existing_caps.add(cap_name)
            if cap_name in known_caps and cap_name not in selected_caps:
                parent.remove(child)

    needed_prefixes = set()
    for cap_name in selected_caps:
        if cap_name in existing_caps:
            continue
        ns_key = CAPABILITY_DEFS.get(cap_name, 'foundation')
        if ns_key == 'foundation':
            ns_uri = foundation_ns
        else:
            ns_uri = NAMESPACE_URIS.get(ns_key, foundation_ns)
            needed_prefixes.add(ns_key)
        cap_el = ET.Element(f"{{{ns_uri}}}Capability")
        cap_el.set('Name', cap_name)
        caps_parent.append(cap_el)

    if needed_prefixes:
        _ensure_ignorable_namespaces(root, needed_prefixes)

    tree.write(path, encoding='utf-8', xml_declaration=True)

def _update_manifest_capabilities(project_dir: Path, selected_caps: set) -> None:
    for path in _get_manifest_paths(project_dir):
        _update_manifest_capabilities_file(path, selected_caps)

def _write_project_config(out_dir: Path, project_type: str, project_name: str, arch: str, publisher: str, include_msvc_dlls: bool) -> Path:
    config = {
        'name': project_name,
        'type': project_type,
        'arch': arch,
        'publisher': publisher or 'CN=Unknown',
        'projectDir': str(out_dir),
        'resourcesDir': '',
        'images': {
            'icon': '',
            'banner': ''
        },
        DEVICE_PORTAL_KEY: {
            'ip': '',
            'username': '',
            'password': ''
        },
        'capabilities': [],
        'includeMsvcDlls': include_msvc_dlls,
        'version': 1
    }
    config_path = out_dir / DEFAULT_CONFIG_NAME
    config_path.write_text(json.dumps(config, indent=2), encoding='utf-8')
    return config_path

def copy_tree(src: Path, dst: Path, replacements, skip_binary_replace=True):
    for root, dirs, files in os.walk(src):
        rel = Path(root).relative_to(src)
        target_dir = dst.joinpath(rel)
        target_dir.mkdir(parents=True, exist_ok=True)
        for f in files:
            s = Path(root) / f
            d = target_dir / f
            shutil.copy2(s, d)
            if is_text_file(s):
                replace_in_file(d, replacements)

def generate_project(template_dir: Path, project_type: str, project_name: str, out_dir: Path, arch: str, publisher: str, reuse_images: Optional[Path], overwrite: bool, include_msvc_dlls: bool):
    if out_dir.exists() and any(out_dir.iterdir()) and not overwrite:
        raise FileExistsError(f"Output directory {out_dir} exists and is not empty (use --overwrite).")

    tmp = Path(tempfile.mkdtemp(prefix='mingw_uwp_'))
    try:
        staging = tmp / project_name
        staging.mkdir()

        src_template = template_dir / project_type
        if not src_template.exists():
            raise FileNotFoundError(f"Template for '{project_type}' not found in {template_dir}")

        replacements = {
            '__PROJECT_NAME__': project_name,
            'CoreAppMinGW': project_name,
            '__PROJECT_NAMESPACE__': sanitize_namespace(project_name),
            '__PUBLISHER__': publisher or 'CN=Unknown',
            'CN=Unknown': publisher or 'CN=Unknown'
        }

        copy_tree(src_template, staging, replacements)

        if project_type in ('xaml', 'corewindow') and reuse_images and reuse_images.exists():
            dest_images = staging / 'Images'
            shutil.copytree(reuse_images, dest_images, dirs_exist_ok=True)

        for p in staging.rglob('*'):
            if p.is_file() and is_text_file(p):
                replace_in_file(p, replacements)

        meta = {
            'project': project_name,
            'namespace': sanitize_namespace(project_name),
            'arch': arch,
            'guid_generated': str(uuid.uuid4())
        }
        (staging / 'metadata.json').write_text(json.dumps(meta, indent=2), encoding='utf-8')

        if out_dir.exists() and out_dir.is_dir():
            shutil.rmtree(out_dir)
        shutil.move(str(staging), str(out_dir))
        _ensure_deps_layout(out_dir)
        if include_msvc_dlls:
            _copy_msvc_dlls(out_dir, arch)
        _write_project_config(out_dir, project_type, project_name, arch, publisher, include_msvc_dlls)
        _write_project_readme(out_dir, project_name, project_type)
        _write_install_script(out_dir, project_name)
        _success(f"Project created: {out_dir}")
    finally:
        try:
            if tmp.exists():
                shutil.rmtree(tmp)
        except Exception:
            pass

def _load_config(path: Path) -> dict:
    try:
        data = json.loads(path.read_text(encoding='utf-8'))
    except FileNotFoundError:
        _error(f"‚ùå Configuration file not found: {path}")
        sys.exit(1)
    except json.JSONDecodeError as exc:
        _error(f"‚ùå Error parsing config file: {exc}")
        sys.exit(1)
    return data

def _save_config(path: Path, data: dict) -> None:
    path.write_text(json.dumps(data, indent=2), encoding='utf-8')

def _load_config_safe(path: Path) -> Optional[dict]:
    try:
        return json.loads(path.read_text(encoding='utf-8'))
    except Exception:
        return None

def _resolve_project_config_for_dir(project_dir: Path) -> Optional[Path]:
    for candidate in (project_dir, project_dir.parent):
        config_path = candidate / DEFAULT_CONFIG_NAME
        if config_path.exists():
            return config_path
    return None

def _read_device_portal_settings(config_path: Optional[Path]) -> dict:
    if not config_path or not config_path.exists():
        return {}
    data = _load_config_safe(config_path)
    if not isinstance(data, dict):
        return {}
    portal = data.get(DEVICE_PORTAL_KEY, {})
    if isinstance(portal, dict):
        return portal
    return {}

def _save_device_portal_settings(config_path: Optional[Path], settings: dict) -> None:
    if not config_path:
        return
    data = _load_config_safe(config_path) or {}
    data[DEVICE_PORTAL_KEY] = settings
    _save_config(config_path, data)

def _load_device_portal_from_json(json_path: Path) -> dict:
    data = _load_config_safe(json_path)
    if not isinstance(data, dict):
        return {}
    if DEVICE_PORTAL_KEY in data and isinstance(data[DEVICE_PORTAL_KEY], dict):
        portal = data.get(DEVICE_PORTAL_KEY, {})
    else:
        portal = data
    if not isinstance(portal, dict):
        return {}
    return {
        "ip": portal.get("ip", ""),
        "username": portal.get("username", ""),
        "password": portal.get("password", ""),
    }

def _load_tool_db() -> dict:
    if not TOOL_DB_PATH.exists():
        return {}
    try:
        data = json.loads(TOOL_DB_PATH.read_text(encoding='utf-8'))
    except Exception:
        return {}
    return data if isinstance(data, dict) else {}

def _save_tool_db(data: dict) -> None:
    try:
        TOOL_DB_PATH.write_text(json.dumps(data, indent=2), encoding='utf-8')
    except Exception:
        pass

def _remember_tool_path(key: str, value: str) -> None:
    value = value.strip()
    if not value:
        return
    data = _load_tool_db()
    data[key] = value
    _save_tool_db(data)

def _suggest_msix_output(build_dir: Path) -> Path:
    manifest_path = _find_appx_manifest(build_dir)
    base_name = ''
    if manifest_path:
        identity_name, _ = _read_manifest_identity(manifest_path)
        base_name = identity_name or ''
    if not base_name:
        base_name = build_dir.name or 'app'
    safe_name = re.sub(r'[^0-9A-Za-z_.-]', '_', base_name)
    return build_dir / f"{safe_name}.msix"

def _run_makemsix(tool_path: str, build_dir: Path, output_path: Path) -> tuple[bool, str]:
    manifest_path = _find_appx_manifest(build_dir)
    if not manifest_path:
        return False, f"AppxManifest.xml not found in {build_dir}"
    if not output_path:
        return False, "Output MSIX path is required."
    output_path.parent.mkdir(parents=True, exist_ok=True)
    exe = tool_path.strip() or "makemsix"
    command = [exe, "pack", "-d", str(build_dir), "-p", str(output_path)]
    try:
        completed = subprocess.run(command, capture_output=True, text=True)
    except FileNotFoundError:
        return False, f"makemsix not found: {exe}"
    except Exception as exc:
        return False, f"makemsix failed: {exc}"
    output = (completed.stdout or "") + (completed.stderr or "")
    normalized = output.strip()
    if completed.returncode == 0:
        return True, normalized
    if "Unrecognized command: pack" in output or ("Commands:" in output and "pack" not in output):
        hint = (
            "This makemsix build does not support the 'pack' command. "
            "Install a pack-capable build compile with --pack!."
        )
        return False, (normalized + "\n" + hint).strip()
    return False, normalized or f"makemsix failed with exit code {completed.returncode}."

def _install_msix_local(package_path: Path) -> tuple[bool, str]:
    if not WINDOWS:
        return False, "MSIX installation is only available on Windows."
    if not package_path.exists():
        return False, f"Package not found: {package_path}"
    command = f"Add-AppxPackage -Path \"{package_path}\" -ErrorAction Stop"
    code, output = _run_powershell(command)
    if code == 0:
        return True, output.strip()
    return False, output.strip()

def _build_multipart_files(parts: list[tuple[str, Path]]) -> tuple[bytes, str]:
    boundary = f"----codex{uuid.uuid4().hex}"
    body = bytearray()
    for field_name, file_path in parts:
        header = (
            f"--{boundary}\r\n"
            f"Content-Disposition: form-data; name=\"{field_name}\"; filename=\"{file_path.name}\"\r\n"
            "Content-Type: application/octet-stream\r\n\r\n"
        ).encode("utf-8")
        body.extend(header)
        body.extend(file_path.read_bytes())
        body.extend(b"\r\n")
    body.extend(f"--{boundary}--\r\n".encode("utf-8"))
    return bytes(body), boundary

def _multipart_content_length(parts: list[tuple[str, Path]], boundary: str) -> int:
    total = 0
    for field_name, file_path in parts:
        header = (
            f"--{boundary}\r\n"
            f"Content-Disposition: form-data; name=\"{field_name}\"; filename=\"{file_path.name}\"\r\n"
            "Content-Type: application/octet-stream\r\n\r\n"
        ).encode("utf-8")
        total += len(header)
        total += file_path.stat().st_size
        total += len(b"\r\n")
    total += len(f"--{boundary}--\r\n".encode("utf-8"))
    return total

def _send_multipart_stream(conn: http.client.HTTPConnection, parts: list[tuple[str, Path]], boundary: str) -> None:
    for field_name, file_path in parts:
        header = (
            f"--{boundary}\r\n"
            f"Content-Disposition: form-data; name=\"{field_name}\"; filename=\"{file_path.name}\"\r\n"
            "Content-Type: application/octet-stream\r\n\r\n"
        ).encode("utf-8")
        conn.send(header)
        with file_path.open("rb") as handle:
            while True:
                chunk = handle.read(1024 * 1024)
                if not chunk:
                    break
                conn.send(chunk)
        conn.send(b"\r\n")
    conn.send(f"--{boundary}--\r\n".encode("utf-8"))

def _collect_dependencies_for_package(package_path: Path) -> list[Path]:
    deps_dir = package_path.parent / "Dependencies"
    if not deps_dir.exists() or not deps_dir.is_dir():
        return []
    x64_dir = deps_dir / "x64"
    search_root = x64_dir if x64_dir.exists() and x64_dir.is_dir() else deps_dir
    deps = []
    for dep in search_root.glob("*.appx"):
        if dep.is_file():
            deps.append(dep)
    return deps

def _deploy_msix_remote(package_path: Path, host: str, username: str, password: str) -> tuple[bool, str]:
    if not package_path.exists():
        return False, f"Package not found: {package_path}"
    base_url = _normalize_wdp_host(host)
    if not base_url:
        return False, "Device IP/host is required."
    encoded_name = urllib.parse.quote(package_path.name)
    url = f"{base_url}/api/app/packagemanager/package?package={encoded_name}"
    dependencies = _collect_dependencies_for_package(package_path)
    parts = [("package", package_path)]
    for dep in dependencies:
        parts.append(("dependency", dep))
    boundary = f"----codex{uuid.uuid4().hex}"
    content_length = _multipart_content_length(parts, boundary)

    parsed = urllib.parse.urlparse(url)
    context = ssl._create_unverified_context()
    try:
        conn = http.client.HTTPSConnection(
            parsed.hostname,
            parsed.port or 443,
            context=context,
            timeout=240,
        )
        path = parsed.path + (f"?{parsed.query}" if parsed.query else "")
        conn.putrequest("POST", path)
        conn.putheader("Content-Type", f"multipart/form-data; boundary={boundary}")
        conn.putheader("Content-Length", str(content_length))
        if username or password:
            token = base64.b64encode(f"{username}:{password}".encode('utf-8')).decode('ascii')
            conn.putheader("Authorization", f"Basic {token}")
        conn.endheaders()
        _send_multipart_stream(conn, parts, boundary)
        response = conn.getresponse()
        status = response.status
        payload = response.read().decode('utf-8', errors='ignore').strip()
        conn.close()
        if status in (200, 202):
            if dependencies:
                payload = (payload + f"\nIncluded dependencies: {len(dependencies)}").strip()
            return True, payload or "Install request accepted."
        if dependencies:
            payload = (payload + f"\nIncluded dependencies: {len(dependencies)}").strip()
        return False, payload or f"Deploy failed with status {status}."
    except (socket.timeout, TimeoutError) as exc:
        size_mb = content_length / (1024 * 1024)
        return False, f"Upload timed out while sending {size_mb:.1f} MB. The portal may be slow; try wired or smaller packages. ({exc})"
    except OSError as exc:
        if "timed out" in str(exc).lower():
            size_mb = content_length / (1024 * 1024)
            return False, f"Upload timed out while sending {size_mb:.1f} MB. The portal may be slow; try wired or smaller packages. ({exc})"
        return False, f"Deploy failed: {exc}"
    except Exception as exc:
        return False, f"Deploy failed: {exc}"

def _run_osslsigncode(tool_path: str, cert_path: Path, password: str, name: str, input_msix: Path, output_msix: Path) -> tuple[bool, str]:
    if not cert_path.exists():
        return False, f"PFX not found: {cert_path}"
    if not input_msix.exists():
        return False, f"Input MSIX not found: {input_msix}"
    exe = tool_path.strip() or "osslsigncode"
    command = [
        exe, "sign",
        "-pkcs12", str(cert_path),
        "-pass", password,
        "-n", name,
        "-in", str(input_msix),
        "-out", str(output_msix),
    ]
    try:
        completed = subprocess.run(command, capture_output=True, text=True)
    except FileNotFoundError:
        return False, f"osslsigncode not found: {exe}"
    except Exception as exc:
        return False, f"osslsigncode failed: {exc}"
    output = (completed.stdout or "") + (completed.stderr or "")
    if completed.returncode == 0:
        return True, output.strip()
    return False, output.strip() or f"osslsigncode failed with exit code {completed.returncode}."

def _create_pfx_with_openssl(key_path: Path, cert_path: Path, days: int, subject: str, output_path: Path, password: str) -> tuple[bool, str]:
    openssl_path = shutil.which("openssl")
    if not openssl_path:
        return False, "OpenSSL not found. Install OpenSSL and try again."
    if not subject:
        return False, "Certificate subject is required (example: CN=Unknown)."
    if not password:
        return False, "PFX password is required."
    output_path.parent.mkdir(parents=True, exist_ok=True)
    key_path.parent.mkdir(parents=True, exist_ok=True)
    cert_path.parent.mkdir(parents=True, exist_ok=True)
    req_cmd = [
        openssl_path, "req", "-x509", "-newkey", "rsa:2048",
        "-nodes", "-keyout", str(key_path), "-out", str(cert_path),
        "-days", str(days), "-subj", f"/{subject}"
    ]
    req_completed = subprocess.run(req_cmd, capture_output=True, text=True)
    if req_completed.returncode != 0:
        output = (req_completed.stdout or "") + (req_completed.stderr or "")
        return False, output.strip() or "OpenSSL certificate creation failed."
    pfx_cmd = [
        openssl_path, "pkcs12", "-export",
        "-out", str(output_path),
        "-inkey", str(key_path),
        "-in", str(cert_path),
        "-passout", f"pass:{password}",
    ]
    pfx_completed = subprocess.run(pfx_cmd, capture_output=True, text=True)
    output = (pfx_completed.stdout or "") + (pfx_completed.stderr or "")
    if pfx_completed.returncode == 0:
        return True, output.strip() or "PFX created."
    return False, output.strip() or "OpenSSL PFX export failed."

def _create_self_signed_pfx(subject: str, password: str, output_path: Path) -> tuple[bool, str]:
    if not subject:
        return False, "Certificate subject is required (example: CN=MyApp)."
    if not password:
        return False, "PFX password is required."
    if not output_path:
        return False, "PFX output path is required."
    output_path.parent.mkdir(parents=True, exist_ok=True)
    if WINDOWS:
        subject_safe = subject.replace("'", "''")
        password_safe = password.replace("'", "''")
        output_safe = str(output_path).replace("'", "''")
        script = (
            "$pwd = ConvertTo-SecureString '{password}' -AsPlainText -Force;"
            "$cert = New-SelfSignedCertificate -Type CodeSigningCert -Subject '{subject}' "
            "-CertStoreLocation 'Cert:\\CurrentUser\\My';"
            "Export-PfxCertificate -Cert $cert -FilePath '{output}' -Password $pwd | Out-Null;"
            "Remove-Item 'Cert:\\CurrentUser\\My\\$($cert.Thumbprint)' -ErrorAction SilentlyContinue | Out-Null;"
            "Write-Output 'PFX created.'"
        ).format(password=password_safe, subject=subject_safe, output=output_safe)
        code, output = _run_powershell(script)
        if code == 0:
            return True, output.strip()
        return False, output.strip() or "Failed to create PFX."
    openssl_path = shutil.which("openssl")
    if not openssl_path:
        return False, "OpenSSL not found. Install OpenSSL or run on Windows to create a PFX."
    temp_dir = Path(tempfile.mkdtemp())
    key_path = temp_dir / "key.pem"
    cert_path = temp_dir / "cert.pem"
    try:
        req_cmd = [
            openssl_path, "req", "-x509", "-newkey", "rsa:2048",
            "-keyout", str(key_path), "-out", str(cert_path),
            "-days", "365", "-nodes", "-subj", f"/{subject}"
        ]
        req_completed = subprocess.run(req_cmd, capture_output=True, text=True)
        if req_completed.returncode != 0:
            output = (req_completed.stdout or "") + (req_completed.stderr or "")
            return False, output.strip() or "OpenSSL certificate creation failed."
        pfx_cmd = [
            openssl_path, "pkcs12", "-export",
            "-out", str(output_path),
            "-inkey", str(key_path),
            "-in", str(cert_path),
            "-passout", f"pass:{password}",
        ]
        pfx_completed = subprocess.run(pfx_cmd, capture_output=True, text=True)
        output = (pfx_completed.stdout or "") + (pfx_completed.stderr or "")
        if pfx_completed.returncode == 0:
            return True, output.strip() or "PFX created."
        return False, output.strip() or "OpenSSL PFX export failed."
    finally:
        shutil.rmtree(temp_dir, ignore_errors=True)

def _find_appx_manifest(build_dir: Path) -> Optional[Path]:
    for name in ('AppxManifest.xml', 'AppxManifest.appxmanifest'):
        candidate = build_dir / name
        if candidate.exists():
            return candidate
    return None

def _read_manifest_identity(manifest_path: Path) -> tuple[str, str]:
    try:
        tree = ET.parse(str(manifest_path))
        root = tree.getroot()
        identity = root.find('./{*}Identity')
        identity_name = identity.get('Name') if identity is not None else ''
        app_id = ''
        applications = root.find('./{*}Applications')
        if applications is not None:
            app_el = applications.find('./{*}Application')
            if app_el is not None:
                app_id = app_el.get('Id') or ''
        return identity_name or '', app_id or ''
    except Exception:
        return '', ''

def _run_powershell(command: str, cwd: Optional[Path] = None) -> tuple[int, str]:
    if not WINDOWS:
        return 1, "PowerShell is only available on Windows."
    completed = subprocess.run(
        ["powershell.exe", "-NoProfile", "-ExecutionPolicy", "Bypass", "-Command", command],
        cwd=str(cwd) if cwd else None,
        capture_output=True,
        text=True,
    )
    output = ""
    if completed.stdout:
        output += completed.stdout
    if completed.stderr:
        output += completed.stderr
    return completed.returncode, output

def _extract_activity_id(text: str) -> Optional[str]:
    match = re.search(r'ActivityId:\s*([0-9a-fA-F-]+)', text)
    if match:
        return match.group(1)
    return None

def _collect_deployment_log(activity_id: str) -> str:
    command = f"Get-AppxLog -ActivityID {activity_id} | Out-String"
    _, output = _run_powershell(command)
    return output.strip()

def _collect_runtime_logs(identity_name: str, minutes: int = 10) -> str:
    if not identity_name:
        return "Package identity not found; cannot filter runtime logs."
    script = (
        "$pkg = Get-AppxPackage -Name \"{name}\" | Select-Object -First 1;"
        "if (-not $pkg) {{ Write-Output \"Package not found for identity.\"; exit 0 }};"
        "$family = [regex]::Escape($pkg.PackageFamilyName);"
        "$events = Get-WinEvent -FilterHashtable @{{LogName='Microsoft-Windows-AppModel-Runtime/Admin'; StartTime=(Get-Date).AddMinutes(-{minutes})}} "
        "| Where-Object {{ $_.Message -match $family }} | Select-Object -First 30;"
        "if (-not $events) {{ Write-Output \"No recent AppModel-Runtime errors found.\"; exit 0 }};"
        "$events | Format-List TimeCreated, Id, LevelDisplayName, Message"
    ).format(name=identity_name.replace('"', '\\"'), minutes=minutes)
    _, output = _run_powershell(script)
    return output.strip()

def _collect_debug_output(identity_name: str, minutes: int = 10) -> str:
    if not WINDOWS:
        return "Debug output collection is only available on Windows."
    if not identity_name:
        return "Package identity not found; cannot filter debug output."
    script = (
        "$pkg = Get-AppxPackage -Name \"{name}\" | Select-Object -First 1;"
        "if (-not $pkg) {{ Write-Output \"Package not found for identity.\"; exit 0 }};"
        "$family = [regex]::Escape($pkg.PackageFamilyName);"
        "$logs = @('Microsoft-Windows-AppModel-Runtime/Debug','Microsoft-Windows-Diagnostics-Logging/Operational');"
        "$events = @();"
        "foreach ($log in $logs) {{"
        "  try {{"
        "    $events += Get-WinEvent -FilterHashtable @{{LogName=$log; StartTime=(Get-Date).AddMinutes(-{minutes})}} "
        "      | Where-Object {{ $_.Message -match $family }};"
        "  }} catch {{ }}"
        "}};"
        "if (-not $events) {{ Write-Output \"No recent debug output found. Ensure debug logs are enabled.\"; exit 0 }};"
        "$events | Select-Object -First 50 | Format-List TimeCreated, Id, Message"
    ).format(name=identity_name.replace('"', '\\"'), minutes=minutes)
    _, output = _run_powershell(script)
    return output.strip()

def _collect_crash_logs(identity_name: str, minutes: int = 60) -> str:
    if not WINDOWS:
        return "Crash log collection is only available on Windows."
    if not identity_name:
        return "Package identity not found; cannot filter crash logs."
    script = (
        "$pkg = Get-AppxPackage -Name \"{name}\" | Select-Object -First 1;"
        "if (-not $pkg) {{ Write-Output \"Package not found for identity.\"; exit 0 }};"
        "$family = [regex]::Escape($pkg.PackageFamilyName);"
        "$events = Get-WinEvent -FilterHashtable @{{LogName='Microsoft-Windows-AppModel-Runtime/Admin'; StartTime=(Get-Date).AddMinutes(-{minutes})}} "
        "| Where-Object {{ ($_.LevelDisplayName -in @('Error','Critical')) -and $_.Message -match $family }} "
        "| Select-Object -First 50;"
        "if (-not $events) {{ Write-Output \"No recent crash events found.\"; exit 0 }};"
        "$events | Format-List TimeCreated, Id, LevelDisplayName, Message"
    ).format(name=identity_name.replace('"', '\\"'), minutes=minutes)
    _, output = _run_powershell(script)
    return output.strip()

def _register_appx(manifest_path: Path) -> tuple[bool, str]:
    command = f"Add-AppxPackage -Register \"{manifest_path}\" -Verbose -ErrorAction Stop"
    code, output = _run_powershell(command, cwd=manifest_path.parent)
    if code == 0:
        return True, output.strip()
    activity_id = _extract_activity_id(output)
    if activity_id:
        log_output = _collect_deployment_log(activity_id)
        if log_output:
            output = output + "\n\n=== Deployment Log ===\n" + log_output
    return False, output.strip()

def _launch_app(identity_name: str, app_id: str) -> tuple[bool, str]:
    if not identity_name or not app_id:
        return False, "Missing package identity or application id in manifest."
    script = (
        "$pkg = Get-AppxPackage -Name \"{name}\" | Select-Object -First 1;"
        "if (-not $pkg) {{ Write-Output \"Package not found after registration.\"; exit 1 }};"
        "$appid = \"{appid}\";"
        "Start-Process \"shell:AppsFolder\\$($pkg.PackageFamilyName)!$appid\""
    ).format(name=identity_name.replace('"', '\\"'), appid=app_id.replace('"', '\\"'))
    code, output = _run_powershell(script)
    if code == 0:
        return True, output.strip()
    return False, output.strip()

def _normalize_wdp_host(host: str) -> str:
    host = host.strip()
    if not host:
        return ''
    if host.startswith('http://') or host.startswith('https://'):
        return host.rstrip('/')
    if ':' in host:
        return f"https://{host}"
    return f"https://{host}:11443"

def _deploy_loose_remote(network_share: str, host: str, username: str, password: str) -> tuple[bool, str]:
    if not network_share:
        return False, "Network share is required for loose deployment."
    base_url = _normalize_wdp_host(host)
    if not base_url:
        return False, "Device IP/host is required."
    url = f"{base_url}/api/app/packagemanager/networkapp"
    payload = {
        "mainpackage": {
            "networkshare": network_share,
            "username": username or "",
            "password": password or "",
        }
    }
    data = json.dumps(payload).encode('utf-8')
    request_obj = urllib.request.Request(url, data=data, method='POST')
    request_obj.add_header('Content-Type', 'application/json')
    if username or password:
        token = base64.b64encode(f"{username}:{password}".encode('utf-8')).decode('ascii')
        request_obj.add_header('Authorization', f'Basic {token}')
    context = ssl._create_unverified_context()
    try:
        with urllib.request.urlopen(request_obj, context=context, timeout=30) as response:
            status = response.getcode()
            body = response.read().decode('utf-8', errors='ignore')
            if status == 200:
                return True, body.strip() or "Deploy request accepted."
            return False, body.strip() or f"Deploy failed with status {status}."
    except urllib.error.HTTPError as exc:
        detail = exc.read().decode('utf-8', errors='ignore') if exc.fp else str(exc)
        return False, f"Deploy failed: {detail or exc}"
    except Exception as exc:
        return False, f"Deploy failed: {exc}"

def _prompt(text: str, current: str) -> str:
    value = input(f"{text} [{current}]: ").strip()
    if value == '-':
        return ''
    return value or current

def _prompt_choice(text: str, current: str, choices) -> str:
    choices_str = "/".join(choices)
    value = input(f"{text} ({choices_str}) [{current}]: ").strip().lower()
    if not value:
        return current
    if value not in choices:
        _warn(f"‚ö†Ô∏è  Invalid choice '{value}', keeping '{current}'.")
        return current
    return value

def _prompt_capabilities(current_caps: set) -> set:
    known_caps = sorted(CAPABILITY_DEFS.keys())
    _info("Known capabilities: " + ", ".join(known_caps))
    value = input("Enable capabilities (comma-separated, '-' to clear, blank to keep): ").strip()
    if not value:
        return current_caps
    if value == '-':
        return set()
    requested = {v.strip() for v in value.split(',') if v.strip()}
    enabled = {cap for cap in requested if cap in known_caps}
    unknown = requested - enabled
    if unknown:
        _warn("‚ö†Ô∏è  Unknown capabilities ignored: " + ", ".join(sorted(unknown)))
    return enabled

def _resolve_project_dir(config_path: Path, data: dict) -> Path:
    project_dir = data.get('projectDir')
    if project_dir:
        return Path(project_dir).expanduser().resolve()
    return config_path.parent.resolve()

def _update_manifest_publisher(project_dir: Path, publisher: str) -> None:
    for name in ('AppxManifest.in', 'AppxManifest.xml'):
        path = project_dir / name
        if not path.exists():
            continue
        try:
            text = path.read_text(encoding='utf-8')
        except Exception:
            continue
        updated = re.sub(r'Publisher="[^"]*"', f'Publisher="{publisher}"', text)
        if updated != text:
            path.write_text(updated, encoding='utf-8')

def _update_metadata(project_dir: Path, arch: str) -> None:
    path = project_dir / 'metadata.json'
    if not path.exists():
        return
    try:
        data = json.loads(path.read_text(encoding='utf-8'))
    except Exception:
        return
    data['arch'] = arch
    path.write_text(json.dumps(data, indent=2), encoding='utf-8')

def _is_valid_aspect_ratio(w: int, h: int) -> bool:
    if h == 0:
        return False
    ratio = w / h
    return 1.6 <= ratio <= 2.4

def _get_target_size(path: Path, fallback: tuple) -> tuple:
    if Image is None:
        return fallback
    if path.exists():
        try:
            with Image.open(path) as img:
                return img.size
        except Exception:
            return fallback
    return fallback

def _sync_images(project_dir: Path, resources_dir: str, icon_path: str, banner_path: str) -> None:
    if Image is None:
        _warn("‚ö†Ô∏è  Pillow not installed; skipping image updates.")
        return

    images_dir = project_dir / 'Images'
    if not images_dir.exists():
        _warn(f"‚ö†Ô∏è  Images directory not found at {images_dir}")
        return

    resources_path = Path(resources_dir).expanduser().resolve() if resources_dir else None

    icon_candidates = []
    banner_candidates = []
    if resources_path and resources_path.exists():
        icon_candidates = [
            resources_path / 'icon.png',
            resources_path / 'icon.jpg',
            resources_path / 'icon.jpeg',
            resources_path / 'logo.png',
            resources_path / 'logo.jpg',
            resources_path / 'logo.jpeg',
            resources_path / 'icon-only.png',
            resources_path / 'icon-only.jpg',
        ]
        banner_candidates = [
            resources_path / 'banner.png',
            resources_path / 'banner.jpg',
            resources_path / 'banner.jpeg',
        ]

    if icon_path:
        chosen_icon = Path(icon_path).expanduser().resolve()
    else:
        chosen_icon = next((c for c in icon_candidates if c.exists()), None)

    if banner_path:
        chosen_banner = Path(banner_path).expanduser().resolve()
    else:
        chosen_banner = next((c for c in banner_candidates if c.exists()), None)

    square_targets = {
        'LockScreenLogo.png': (24, 24),
        'Square44x44Logo.png': (44, 44),
        'Square150x150Logo.png': (150, 150),
        'StoreLogo.png': (50, 50),
    }
    banner_targets = {
        'SplashScreen.png': (620, 300),
        'Wide310x150Logo.png': (310, 150),
    }

    if chosen_icon and chosen_icon.exists():
        try:
            with Image.open(chosen_icon) as img:
                w, h = img.size
            if w == h:
                _info(f"üñº  Resizing square icon: {chosen_icon}")
                for name, fallback in square_targets.items():
                    dest = images_dir / name
                    size = _get_target_size(dest, fallback)
                    with Image.open(chosen_icon) as img:
                        resized = img.resize(size, Image.Resampling.LANCZOS)
                        resized.save(dest)
                _success("‚úÖ Icons updated.")
            else:
                _warn("‚ö†Ô∏è  Icon is not square; skipping icon updates.")
        except Exception as exc:
            _error(f"‚ùå Error processing icon: {exc}")
    else:
        _warn("‚ö†Ô∏è  No icon found; skipping icon updates.")

    if chosen_banner and chosen_banner.exists():
        try:
            with Image.open(chosen_banner) as img:
                w, h = img.size
            if _is_valid_aspect_ratio(w, h):
                ratio = w / h
                _info(f"üñº  Resizing banner (ratio {ratio:.2f}): {chosen_banner}")
                for name, fallback in banner_targets.items():
                    dest = images_dir / name
                    size = _get_target_size(dest, fallback)
                    with Image.open(chosen_banner) as img:
                        resized = img.resize(size, Image.Resampling.LANCZOS)
                        resized.save(dest)
                _success("‚úÖ Banners updated.")
            else:
                ratio = w / h
                _warn(f"‚ö†Ô∏è  Banner ratio {ratio:.2f} is outside 1.6‚Äì2.4; skipping banner updates.")
        except Exception as exc:
            _error(f"‚ùå Error processing banner: {exc}")
    else:
        _warn("‚ö†Ô∏è  No banner found; skipping banner updates.")

def edit_project_config(config_path: Path) -> None:
    data = _load_config(config_path)
    project_dir = _resolve_project_dir(config_path, data)
    if not project_dir.exists():
        _warn(f"‚ö†Ô∏è  Project directory not found: {project_dir}")

    _info("üõ†  Project editor")
    name = data.get('name', project_dir.name)
    arch = data.get('arch', 'x64')
    publisher = data.get('publisher', 'CN=Unknown')
    resources_dir = data.get('resourcesDir', '')
    images = data.get('images', {}) or {}
    icon_path = images.get('icon', '')
    banner_path = images.get('banner', '')
    include_msvc_dlls = bool(data.get('includeMsvcDlls', False))
    manifest_paths = _get_manifest_paths(project_dir)
    current_caps = set()
    if manifest_paths:
        current_caps = _read_manifest_capabilities(manifest_paths[0])

    arch = _prompt_choice("Architecture", arch, ARCH_CHOICES)
    publisher = _prompt("Publisher (CN=...)", publisher)
    resources_dir = _prompt("Resources directory", resources_dir)
    icon_path = _prompt("Icon image path (optional)", icon_path)
    banner_path = _prompt("Banner image path (optional)", banner_path)
    include_msvc = _prompt("Include MSVC DLLs (yes/no)", "yes" if include_msvc_dlls else "no").lower() in ("y", "yes", "true", "1")
    selected_caps = _prompt_capabilities(current_caps)

    data['name'] = name
    data['arch'] = arch
    data['publisher'] = publisher
    data['resourcesDir'] = resources_dir
    data['projectDir'] = str(project_dir)
    data['images'] = {
        'icon': icon_path,
        'banner': banner_path
    }
    data['capabilities'] = sorted(selected_caps)
    data['includeMsvcDlls'] = include_msvc

    _save_config(config_path, data)
    _update_metadata(project_dir, arch)
    _update_manifest_publisher(project_dir, publisher)
    if manifest_paths:
        _update_manifest_capabilities(project_dir, selected_caps)
    _sync_images(project_dir, resources_dir, icon_path, banner_path)
    if include_msvc and project_dir.exists():
        _ensure_deps_layout(project_dir)
        _copy_msvc_dlls(project_dir, arch)
    _success(f"‚úÖ Updated config: {config_path}")

def _apply_vs_style(root):
    from tkinter import ttk

    colors = {
        "bg": "#1e1e1e",
        "panel": "#252526",
        "panel_light": "#2d2d30",
        "panel_dark": "#1b1b1c",
        "border": "#3f3f46",
        "text": "#d4d4d4",
        "muted": "#9e9e9e",
        "accent": "#0e639c",
        "accent_hover": "#1177bb",
    }

    style = ttk.Style(root)
    try:
        style.theme_use("clam")
    except Exception:
        pass

    style.configure("App.TFrame", background=colors["bg"])
    style.configure("TFrame", background=colors["bg"])
    style.configure("Header.TFrame", background=colors["panel"])
    style.configure("Nav.TFrame", background=colors["panel_dark"])
    style.configure("Content.TFrame", background=colors["bg"])
    style.configure("Card.TLabelframe", background=colors["panel"], bordercolor=colors["border"])
    style.configure("Card.TLabelframe.Label", background=colors["panel"], foreground=colors["text"], font=("Segoe UI", 10, "bold"))
    style.configure("TLabelframe", background=colors["panel"], bordercolor=colors["border"])
    style.configure("TLabelframe.Label", background=colors["panel"], foreground=colors["text"])

    style.configure("TLabel", background=colors["bg"], foreground=colors["text"])
    style.configure("Muted.TLabel", background=colors["bg"], foreground=colors["muted"])
    style.configure("Header.TLabel", background=colors["panel"], foreground=colors["text"], font=("Segoe UI", 12, "bold"))

    style.configure("Nav.TButton", background=colors["panel_dark"], foreground=colors["text"], padding=(14, 10), borderwidth=0)
    style.map("Nav.TButton", background=[("active", colors["panel_light"])])
    style.configure("NavActive.TButton", background=colors["accent"], foreground="white", padding=(14, 10), borderwidth=0)
    style.map("NavActive.TButton", background=[("active", colors["accent_hover"])])

    style.configure("Accent.TButton", background=colors["accent"], foreground="white", padding=(12, 8))
    style.map("Accent.TButton", background=[("active", colors["accent_hover"])])
    style.configure("Ghost.TButton", background=colors["panel_light"], foreground=colors["text"], padding=(10, 8))
    style.map("Ghost.TButton", background=[("active", colors["panel"])])

    style.configure("TEntry", fieldbackground=colors["panel_light"], foreground=colors["text"])
    style.configure("TCombobox", fieldbackground=colors["panel_light"], foreground=colors["text"])
    style.map("TCombobox", fieldbackground=[("readonly", colors["panel_light"])])
    style.configure("TCheckbutton", background=colors["bg"], foreground=colors["text"])

    root.configure(bg=colors["bg"])
    return colors

def launch_gui(default_template_dir: Path, default_output_dir: Path, default_arch: str, default_publisher: str, images_dir: Path):
    try:
        import tkinter as tk
        from tkinter import ttk, filedialog, messagebox
    except Exception as exc:
        print(f"Failed to start GUI: {exc}")
        sys.exit(1)

    root = tk.Tk()
    root.title("MinGW UWP Studio")
    root.geometry("980x640")
    root.minsize(900, 560)
    root.resizable(True, True)

    colors = _apply_vs_style(root)
    tool_db = _load_tool_db()

    main = ttk.Frame(root, style="App.TFrame")
    main.pack(fill=tk.BOTH, expand=True)
    main.columnconfigure(1, weight=1)
    main.rowconfigure(1, weight=1)

    header = ttk.Frame(main, style="Header.TFrame", padding=(16, 10))
    header.grid(row=0, column=0, columnspan=2, sticky="ew")
    header.columnconfigure(1, weight=1)

    title = ttk.Label(header, text="MinGW UWP Studio", style="Header.TLabel")
    title.grid(row=0, column=0, sticky="w")
    header.columnconfigure(1, weight=0)

    nav = ttk.Frame(main, style="Nav.TFrame", padding=(8, 12))
    nav.grid(row=1, column=0, sticky="ns")
    nav.columnconfigure(0, weight=1)

    content_container = ttk.Frame(main, style="Content.TFrame")
    content_container.grid(row=1, column=1, sticky="nsew")
    content_container.columnconfigure(0, weight=1)
    content_container.rowconfigure(0, weight=1)

    content_canvas = tk.Canvas(content_container, background=colors["bg"], highlightthickness=0)
    content_scroll = ttk.Scrollbar(content_container, orient=tk.VERTICAL, command=content_canvas.yview)
    content_canvas.configure(yscrollcommand=content_scroll.set)
    content_canvas.grid(row=0, column=0, sticky="nsew")
    content_scroll.grid(row=0, column=1, sticky="ns")

    content = ttk.Frame(content_canvas, style="Content.TFrame", padding=(16, 16))
    content_id = content_canvas.create_window((0, 0), window=content, anchor="nw")
    content.columnconfigure(0, weight=1)

    def _on_content_configure(event):
        content_canvas.configure(scrollregion=content_canvas.bbox("all"))

    def _on_canvas_configure(event):
        content_canvas.itemconfigure(content_id, width=event.width)

    content.bind("<Configure>", _on_content_configure)
    content_canvas.bind("<Configure>", _on_canvas_configure)

    def _on_mousewheel(event):
        if event.delta:
            content_canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
        elif event.num == 4:
            content_canvas.yview_scroll(-3, "units")
        elif event.num == 5:
            content_canvas.yview_scroll(3, "units")

    def _bind_mousewheel(_):
        content_canvas.bind_all("<MouseWheel>", _on_mousewheel)
        content_canvas.bind_all("<Button-4>", _on_mousewheel)
        content_canvas.bind_all("<Button-5>", _on_mousewheel)

    def _unbind_mousewheel(_):
        content_canvas.unbind_all("<MouseWheel>")
        content_canvas.unbind_all("<Button-4>")
        content_canvas.unbind_all("<Button-5>")

    content_canvas.bind("<Enter>", _bind_mousewheel)
    content_canvas.bind("<Leave>", _unbind_mousewheel)

    pages = {}
    nav_buttons = {}

    def show_page(name: str):
        for page in pages.values():
            page.grid_remove()
        pages[name].grid(row=0, column=0, sticky="nsew")
        for key, button in nav_buttons.items():
            button.configure(style="NavActive.TButton" if key == name else "Nav.TButton")
        content_canvas.yview_moveto(0)

    def add_nav_button(name: str, text: str):
        button = ttk.Button(nav, text=text, style="Nav.TButton", command=lambda: show_page(name))
        button.grid(sticky="ew", pady=4)
        nav_buttons[name] = button

    def create_card(parent, title_text):
        frame = ttk.Labelframe(parent, text=title_text, style="Card.TLabelframe", padding=12)
        frame.columnconfigure(1, weight=1)
        return frame

    # Create Project Page
    create_page = ttk.Frame(content, style="Content.TFrame")
    create_page.columnconfigure(0, weight=1)
    create_page.rowconfigure(1, weight=1)

    create_header_row = ttk.Frame(create_page, style="Content.TFrame")
    create_header_row.grid(row=0, column=0, sticky="ew")
    create_header_row.columnconfigure(0, weight=1)
    create_header_row.columnconfigure(1, weight=0)
    create_header = ttk.Label(create_header_row, text="Create a new MinGW UWP project", style="Header.TLabel")
    create_header.grid(row=0, column=0, sticky="w")
    create_subtitle = ttk.Label(create_header_row, text="Configure templates, paths, and build settings.", style="Muted.TLabel")
    create_subtitle.grid(row=0, column=1, sticky="e")

    form_frame = ttk.Frame(create_page, style="Content.TFrame")
    form_frame.grid(row=1, column=0, sticky="nsew", pady=(12, 0))
    form_frame.columnconfigure(0, weight=1)

    settings_card = create_card(form_frame, "Project settings")
    settings_card.grid(row=0, column=0, sticky="ew", pady=(0, 12))

    paths_card = create_card(form_frame, "Paths")
    paths_card.grid(row=1, column=0, sticky="ew", pady=(0, 12))

    options_card = create_card(form_frame, "Options")
    options_card.grid(row=2, column=0, sticky="ew")

    project_type_var = tk.StringVar(value="xaml")
    project_type = ttk.Combobox(settings_card, textvariable=project_type_var, state="readonly")
    project_type["values"] = ("library", "console", "xaml", "corewindow")

    name_var = tk.StringVar(value="MyApp")
    name_entry = ttk.Entry(settings_card, textvariable=name_var)

    arch_var = tk.StringVar(value=default_arch)
    arch_combo = ttk.Combobox(settings_card, textvariable=arch_var, state="readonly")
    arch_combo["values"] = ("x64", "x86", "arm64", "arm")

    publisher_var = tk.StringVar(value=default_publisher)
    publisher_entry = ttk.Entry(settings_card, textvariable=publisher_var)

    def add_row(parent, row, label_text, widget, button=None):
        label = ttk.Label(parent, text=label_text)
        label.grid(row=row, column=0, sticky="w", pady=6)
        widget.grid(row=row, column=1, sticky="ew", padx=(10, 0), pady=6)
        if button is not None:
            button.grid(row=row, column=2, sticky="e", padx=(8, 0), pady=6)

    add_row(settings_card, 0, "Project type", project_type)
    add_row(settings_card, 1, "Project name", name_entry)
    add_row(settings_card, 2, "Architecture", arch_combo)
    add_row(settings_card, 3, "Publisher", publisher_entry)

    output_var = tk.StringVar(value=str(default_output_dir))
    output_entry = ttk.Entry(paths_card, textvariable=output_var)
    output_button = ttk.Button(paths_card, text="Browse", style="Ghost.TButton", command=lambda: output_var.set(filedialog.askdirectory() or output_var.get()))

    template_var = tk.StringVar(value=str(default_template_dir))
    template_entry = ttk.Entry(paths_card, textvariable=template_var)
    template_button = ttk.Button(paths_card, text="Browse", style="Ghost.TButton", command=lambda: template_var.set(filedialog.askdirectory() or template_var.get()))

    add_row(paths_card, 0, "Output directory", output_entry, output_button)
    add_row(paths_card, 1, "Template directory", template_entry, template_button)

    overwrite_var = tk.BooleanVar(value=False)
    include_msvc_var = tk.BooleanVar(value=False)
    ttk.Checkbutton(options_card, text="Overwrite output directory if it exists", variable=overwrite_var).grid(row=0, column=0, sticky="w", pady=4)
    ttk.Checkbutton(options_card, text="Include MSVC DLLs in deps/bin", variable=include_msvc_var).grid(row=1, column=0, sticky="w", pady=4)

    create_status = tk.StringVar(value="")
    status_label = ttk.Label(form_frame, textvariable=create_status, style="Muted.TLabel")
    status_label.grid(row=3, column=0, sticky="w", pady=(10, 0))

    def on_create():
        project_name = name_var.get().strip()
        if not project_name:
            messagebox.showerror("Missing name", "Project name is required.")
            return

        out_dir = Path(output_var.get()).expanduser().resolve() / project_name
        template_dir = Path(template_var.get()).expanduser().resolve()

        try:
            generate_project(
                template_dir=template_dir,
                project_type=project_type_var.get(),
                project_name=project_name,
                out_dir=out_dir,
                arch=arch_var.get(),
                publisher=publisher_var.get().strip() or default_publisher,
                reuse_images=images_dir,
                overwrite=overwrite_var.get(),
                include_msvc_dlls=include_msvc_var.get(),
            )
        except Exception as exc:
            messagebox.showerror("Generation failed", str(exc))
            create_status.set(f"Failed: {exc}")
            return

        messagebox.showinfo("Project created", f"Project created at:\n{out_dir}")
        create_status.set(f"Project created at {out_dir}")

    actions = ttk.Frame(create_page, style="Content.TFrame")
    actions.grid(row=2, column=0, sticky="e", pady=(12, 0))
    ttk.Button(actions, text="Create Project", style="Accent.TButton", command=on_create).grid(row=0, column=0, padx=(0, 8))
    ttk.Button(actions, text="Close", style="Ghost.TButton", command=root.destroy).grid(row=0, column=1)

    pages["create"] = create_page

    # Editor Page
    editor_page = ttk.Frame(content, style="Content.TFrame")
    editor_page.columnconfigure(0, weight=1)
    editor_page.rowconfigure(1, weight=1)

    editor_header_row = ttk.Frame(editor_page, style="Content.TFrame")
    editor_header_row.grid(row=0, column=0, sticky="ew")
    editor_header_row.columnconfigure(0, weight=1)
    editor_header_row.columnconfigure(1, weight=0)
    editor_header = ttk.Label(editor_header_row, text="Edit project configuration", style="Header.TLabel")
    editor_header.grid(row=0, column=0, sticky="w")
    editor_hint = ttk.Label(editor_header_row, text="Open mingw_winrt.json to update capabilities, assets, and metadata.", style="Muted.TLabel")
    editor_hint.grid(row=0, column=1, sticky="e")

    editor_card = create_card(editor_page, "Project config")
    editor_card.grid(row=1, column=0, sticky="ew", pady=(12, 0))

    editor_path_var = tk.StringVar(value="")
    editor_entry = ttk.Entry(editor_card, textvariable=editor_path_var)

    def browse_config():
        path = filedialog.askopenfilename()
        if path:
            editor_path_var.set(path)

    def open_editor():
        path = editor_path_var.get().strip()
        if not path:
            messagebox.showerror("Missing config", "Select a mingw_winrt.json file first.")
            return
        config_path = Path(path)
        if not config_path.exists():
            messagebox.showerror("Missing config", f"Config not found: {config_path}")
            return
        edit_project_config_gui(config_path, parent=root)

    add_row(editor_card, 0, "Config file", editor_entry, ttk.Button(editor_card, text="Browse", style="Ghost.TButton", command=browse_config))
    ttk.Button(editor_page, text="Open Editor", style="Accent.TButton", command=open_editor).grid(row=2, column=0, sticky="e", pady=(12, 0))

    pages["editor"] = editor_page

    # Runner / Installer Page
    runner_page = ttk.Frame(content, style="Content.TFrame")
    runner_page.columnconfigure(0, weight=1)
    runner_page.rowconfigure(4, weight=1)

    runner_header_row = ttk.Frame(runner_page, style="Content.TFrame")
    runner_header_row.grid(row=0, column=0, sticky="ew")
    runner_header_row.columnconfigure(0, weight=1)
    runner_header_row.columnconfigure(1, weight=0)
    runner_header = ttk.Label(runner_header_row, text="Run / Install loose apps", style="Header.TLabel")
    runner_header.grid(row=0, column=0, sticky="w")
    runner_hint = ttk.Label(runner_header_row, text="Register loose builds, install MSIX packages, or deploy via device portal.", style="Muted.TLabel")
    runner_hint.grid(row=0, column=1, sticky="e")

    settings_card = create_card(runner_page, "Device portal settings")
    settings_card.grid(row=1, column=0, sticky="ew", pady=(12, 8))

    local_card = create_card(runner_page, "Loose folder (local + remote)")
    local_card.grid(row=2, column=0, sticky="ew", pady=(0, 12))

    msix_card = create_card(runner_page, "MSIX install / deploy")
    msix_card.grid(row=3, column=0, sticky="ew", pady=(0, 12))

    log_card = create_card(runner_page, "Output")
    log_card.grid(row=4, column=0, sticky="nsew")
    log_card.columnconfigure(0, weight=1)
    log_card.rowconfigure(0, weight=1)

    build_dir_var = tk.StringVar(value=str(Path.cwd()))
    build_dir_entry = ttk.Entry(local_card, textvariable=build_dir_var)

    manifest_status = tk.StringVar(value="Select a build folder that contains AppxManifest.xml.")
    manifest_label = ttk.Label(local_card, textvariable=manifest_status, style="Muted.TLabel")

    launch_after_var = tk.BooleanVar(value=True)

    def append_log(message: str):
        log_text.configure(state="normal")
        log_text.insert(tk.END, message.rstrip() + "\n")
        log_text.see(tk.END)
        log_text.configure(state="disabled")

    def append_log_async(message: str):
        root.after(0, lambda: append_log(message))

    def run_async(task, done_label: Optional[str] = None):
        def _runner():
            try:
                task()
            finally:
                if done_label:
                    append_log_async(done_label)
        threading.Thread(target=_runner, daemon=True).start()

    current_manifest = {"path": None, "identity": "", "app_id": "", "config": None}
    settings_config_state = {"path": None}
    settings_config_var = tk.StringVar(value="")

    def set_settings_config(path: Optional[Path]):
        settings_config_state["path"] = path
        settings_config_var.set(str(path.parent) if path else "")
        if not path:
            ip_var.set("")
            username_var.set("")
            password_var.set("")
            return
        portal = _read_device_portal_settings(path)
        ip_var.set(portal.get("ip", ""))
        username_var.set(portal.get("username", ""))
        password_var.set(portal.get("password", ""))

    def update_manifest_state(path: Optional[Path]):
        current_manifest["path"] = None
        current_manifest["identity"] = ""
        current_manifest["app_id"] = ""
        current_manifest["config"] = None
        if not path:
            manifest_status.set("Select a build folder that contains AppxManifest.xml.")
            return
        manifest_path = _find_appx_manifest(path)
        if not manifest_path:
            manifest_status.set("No AppxManifest.xml found in this folder.")
            return
        identity_name, app_id = _read_manifest_identity(manifest_path)
        current_manifest["path"] = manifest_path
        current_manifest["identity"] = identity_name
        current_manifest["app_id"] = app_id
        config_path = _resolve_project_config_for_dir(path)
        current_manifest["config"] = config_path
        manifest_status.set(f"Manifest OK: {manifest_path.name}")
        set_settings_config(config_path)

    def browse_build_dir():
        path = filedialog.askdirectory()
        if path:
            build_dir_var.set(path)
            update_manifest_state(Path(path))

    def register_and_run():
        if not current_manifest["path"]:
            messagebox.showerror("Missing manifest", "Select a build folder with AppxManifest.xml first.")
            return
        append_log("== Registering appx (loose) ==")
        ok, output = _register_appx(current_manifest["path"])
        if output:
            append_log(output)
        if not ok:
            append_log("Registration failed.")
            return
        append_log("Registration completed.")
        if launch_after_var.get():
            append_log("Launching app...")
            launch_ok, launch_output = _launch_app(current_manifest["identity"], current_manifest["app_id"])
            if launch_output:
                append_log(launch_output)
            if launch_ok:
                append_log("App launched. Collecting recent runtime logs...")
                logs = _collect_runtime_logs(current_manifest["identity"], minutes=10)
                if logs:
                    append_log(logs)
            else:
                append_log("Failed to launch app.")

    add_row(local_card, 0, "Build folder", build_dir_entry, ttk.Button(local_card, text="Browse", style="Ghost.TButton", command=browse_build_dir))
    manifest_label.grid(row=1, column=0, columnspan=3, sticky="w", pady=(0, 8))
    def deploy_loose():
        share_path = build_dir_var.get().strip()
        if not share_path:
            messagebox.showerror("Missing folder", "Select a build folder first.")
            return
        if not (share_path.startswith("\\\\") or share_path.startswith("//")):
            messagebox.showerror("Missing network share", "Remote deploy requires a UNC path (e.g. \\\\host\\share\\path).")
            return
        if not save_portal_settings():
            return
        append_log("== Deploying loose folder to device portal ==")

        def _task():
            ok, output = _deploy_loose_remote(
                share_path,
                ip_var.get().strip(),
                username_var.get().strip(),
                password_var.get().strip(),
            )
            if output:
                append_log_async(output)
            append_log_async("Remote deploy accepted." if ok else "Remote deploy failed.")

        run_async(_task)

    ttk.Checkbutton(local_card, text="Launch after register", variable=launch_after_var).grid(row=2, column=0, sticky="w", pady=(0, 6))
    ttk.Button(local_card, text="Register & Run", style="Accent.TButton", command=register_and_run).grid(row=2, column=2, sticky="e")
    ttk.Button(local_card, text="Deploy to Device", style="Ghost.TButton", command=deploy_loose).grid(row=3, column=2, sticky="e", pady=(0, 6))

    msix_path_var = tk.StringVar(value="")
    msix_status = tk.StringVar(value="Select a .msix/.appx package to install or deploy.")

    def update_msix_status(path: Optional[Path]):
        if not path:
            msix_status.set("Select a .msix/.appx package to install or deploy.")
            return
        if not path.exists():
            msix_status.set("Package not found.")
            return
        msix_status.set(f"Package OK: {path.name}")

    def browse_msix():
        path = filedialog.askopenfilename(filetypes=[("MSIX/AppX packages", "*.msix *.msixbundle *.appx *.appxbundle"), ("All files", "*.*")])
        if path:
            msix_path_var.set(path)
            update_msix_status(Path(path))

    def install_msix():
        path_text = msix_path_var.get().strip()
        if not path_text:
            messagebox.showerror("Missing package", "Select a package file first.")
            return
        package_path = Path(path_text).expanduser().resolve()
        append_log("== Installing MSIX locally ==")
        ok, output = _install_msix_local(package_path)
        if output:
            append_log(output)
        if ok:
            append_log("MSIX install started.")
        else:
            append_log("MSIX install failed.")

    def deploy_msix():
        path_text = msix_path_var.get().strip()
        if not path_text:
            messagebox.showerror("Missing package", "Select a package file first.")
            return
        if not save_portal_settings():
            return
        package_path = Path(path_text).expanduser().resolve()
        append_log("== Deploying MSIX to device portal ==")

        def _task():
            ok, output = _deploy_msix_remote(
                package_path,
                ip_var.get().strip(),
                username_var.get().strip(),
                password_var.get().strip(),
            )
            if output:
                append_log_async(output)
            append_log_async("Remote install accepted." if ok else "Remote install failed.")

        run_async(_task)

    add_row(msix_card, 0, "Package file", ttk.Entry(msix_card, textvariable=msix_path_var), ttk.Button(msix_card, text="Browse", style="Ghost.TButton", command=browse_msix))
    ttk.Label(msix_card, textvariable=msix_status, style="Muted.TLabel").grid(row=1, column=0, columnspan=3, sticky="w", pady=(0, 8))
    msix_actions = ttk.Frame(msix_card, style="Content.TFrame")
    msix_actions.grid(row=2, column=0, columnspan=3, sticky="e", pady=(0, 6))
    ttk.Button(msix_actions, text="Install locally", style="Accent.TButton", command=install_msix).grid(row=0, column=0, padx=(0, 8))
    ttk.Button(msix_actions, text="Deploy to device", style="Ghost.TButton", command=deploy_msix).grid(row=0, column=1)

    ip_var = tk.StringVar(value="")
    username_var = tk.StringVar(value="")
    password_var = tk.StringVar(value="")

    update_manifest_state(Path(build_dir_var.get()))

    def load_settings_config():
        selected = settings_config_var.get().strip()
        if not selected:
            selected = filedialog.askdirectory()
        if not selected:
            return
        candidate = Path(selected).expanduser().resolve()
        if candidate.is_file() and candidate.name == DEFAULT_CONFIG_NAME:
            config_path = candidate
        else:
            config_path = candidate / DEFAULT_CONFIG_NAME
        if not config_path.exists():
            messagebox.showerror("Config not found", f"Missing {DEFAULT_CONFIG_NAME} in {candidate}")
            return
        set_settings_config(config_path)

    add_row(settings_card, 0, "Project folder", ttk.Entry(settings_card, textvariable=settings_config_var), ttk.Button(settings_card, text="Load", style="Ghost.TButton", command=load_settings_config))
    add_row(settings_card, 1, "Device IP / host", ttk.Entry(settings_card, textvariable=ip_var))
    add_row(settings_card, 2, "Username", ttk.Entry(settings_card, textvariable=username_var))
    add_row(settings_card, 3, "Password", ttk.Entry(settings_card, textvariable=password_var, show="*"))

    def save_portal_settings():
        if not settings_config_state["path"]:
            messagebox.showerror("Missing config", "Load a project folder with mingw_winrt.json first.")
            return False
        settings = {
            "ip": ip_var.get().strip(),
            "username": username_var.get().strip(),
            "password": password_var.get().strip(),
        }
        _save_device_portal_settings(settings_config_state["path"], settings)
        return True

    settings_actions = ttk.Frame(settings_card, style="Content.TFrame")
    settings_actions.grid(row=4, column=0, columnspan=3, sticky="e", pady=(10, 0))
    ttk.Button(settings_actions, text="Save Settings", style="Ghost.TButton", command=save_portal_settings).grid(row=0, column=0)

    log_text = tk.Text(log_card, height=10, background=colors["panel"], foreground=colors["text"], insertbackground=colors["text"], borderwidth=0)
    log_text.configure(state="disabled")
    log_scroll = ttk.Scrollbar(log_card, orient=tk.VERTICAL, command=log_text.yview)
    log_text.configure(yscrollcommand=log_scroll.set)
    log_text.grid(row=0, column=0, sticky="nsew")
    log_scroll.grid(row=0, column=1, sticky="ns")

    pages["runner"] = runner_page

    # Packaging Page
    packaging_page = ttk.Frame(content, style="Content.TFrame")
    packaging_page.columnconfigure(0, weight=1)
    packaging_page.rowconfigure(2, weight=1)

    packaging_header_row = ttk.Frame(packaging_page, style="Content.TFrame")
    packaging_header_row.grid(row=0, column=0, sticky="ew")
    packaging_header_row.columnconfigure(0, weight=1)
    packaging_header_row.columnconfigure(1, weight=0)
    packaging_header = ttk.Label(packaging_header_row, text="Package MSIX", style="Header.TLabel")
    packaging_header.grid(row=0, column=0, sticky="w")
    packaging_hint = ttk.Label(packaging_header_row, text="Use makemsix to package a build folder.", style="Muted.TLabel")
    packaging_hint.grid(row=0, column=1, sticky="e")

    packaging_card = create_card(packaging_page, "makemsix")
    packaging_card.grid(row=1, column=0, sticky="ew", pady=(12, 8))

    packaging_log_card = create_card(packaging_page, "Output")
    packaging_log_card.grid(row=2, column=0, sticky="nsew")
    packaging_log_card.columnconfigure(0, weight=1)
    packaging_log_card.rowconfigure(0, weight=1)

    makemsix_tool_var = tk.StringVar(value=tool_db.get("makemsix", ""))
    packaging_build_var = tk.StringVar(value=str(Path.cwd()))
    packaging_output_var = tk.StringVar(value="")
    packaging_status = tk.StringVar(value="Select a build folder that contains AppxManifest.xml.")

    def update_packaging_state(path: Optional[Path]):
        if not path:
            packaging_status.set("Select a build folder that contains AppxManifest.xml.")
            return
        manifest_path = _find_appx_manifest(path)
        if not manifest_path:
            packaging_status.set("No AppxManifest.xml found in this folder.")
            return
        packaging_status.set(f"Manifest OK: {manifest_path.name}")
        if not packaging_output_var.get().strip():
            packaging_output_var.set(str(_suggest_msix_output(path)))

    def browse_makemsix():
        path = filedialog.askopenfilename()
        if path:
            makemsix_tool_var.set(path)
            _remember_tool_path("makemsix", path)

    def browse_packaging_build():
        path = filedialog.askdirectory()
        if path:
            packaging_build_var.set(path)
            update_packaging_state(Path(path))

    def browse_packaging_output():
        initial_dir = packaging_build_var.get().strip() or str(Path.cwd())
        initial_file = Path(packaging_output_var.get()).name if packaging_output_var.get().strip() else ""
        path = filedialog.asksaveasfilename(
            defaultextension=".msix",
            initialdir=initial_dir,
            initialfile=initial_file,
            filetypes=[("MSIX packages", "*.msix"), ("All files", "*.*")]
        )
        if path:
            packaging_output_var.set(path)

    def append_packaging_log(message: str):
        packaging_log_text.configure(state="normal")
        packaging_log_text.insert(tk.END, message.rstrip() + "\n")
        packaging_log_text.see(tk.END)
        packaging_log_text.configure(state="disabled")

    def run_packaging():
        build_dir_text = packaging_build_var.get().strip()
        output_text = packaging_output_var.get().strip()
        if not build_dir_text:
            messagebox.showerror("Missing build folder", "Select a build folder first.")
            return
        if not output_text:
            messagebox.showerror("Missing output", "Select an output .msix file.")
            return
        build_dir = Path(build_dir_text).expanduser().resolve()
        output_path = Path(output_text).expanduser().resolve()
        tool_path = makemsix_tool_var.get().strip()
        if tool_path:
            _remember_tool_path("makemsix", tool_path)
        ok, output = _run_makemsix(tool_path, build_dir, output_path)
        if output:
            append_packaging_log(output)
            print(output)
        if ok:
            messagebox.showinfo("MSIX created", f"MSIX created:\n{output_path}")
        else:
            messagebox.showerror("makemsix failed", output or "makemsix failed.")

    add_row(packaging_card, 0, "makemsix path", ttk.Entry(packaging_card, textvariable=makemsix_tool_var), ttk.Button(packaging_card, text="Browse", style="Ghost.TButton", command=browse_makemsix))
    add_row(packaging_card, 1, "Build folder", ttk.Entry(packaging_card, textvariable=packaging_build_var), ttk.Button(packaging_card, text="Browse", style="Ghost.TButton", command=browse_packaging_build))
    add_row(packaging_card, 2, "Output MSIX", ttk.Entry(packaging_card, textvariable=packaging_output_var), ttk.Button(packaging_card, text="Browse", style="Ghost.TButton", command=browse_packaging_output))
    ttk.Label(packaging_card, textvariable=packaging_status, style="Muted.TLabel").grid(row=3, column=0, columnspan=3, sticky="w", pady=(0, 6))

    packaging_actions = ttk.Frame(packaging_card, style="Content.TFrame")
    packaging_actions.grid(row=4, column=0, columnspan=3, sticky="e", pady=(6, 0))
    ttk.Button(packaging_actions, text="Package MSIX", style="Accent.TButton", command=run_packaging).grid(row=0, column=0, padx=(0, 8))
    ttk.Button(packaging_actions, text="Get makemsix", style="Ghost.TButton", command=lambda: webbrowser.open("https://github.com/microsoft/msix-packaging")).grid(row=0, column=1)

    packaging_log_text = tk.Text(packaging_log_card, height=10, background=colors["panel"], foreground=colors["text"], insertbackground=colors["text"], borderwidth=0)
    packaging_log_text.configure(state="disabled")
    packaging_log_scroll = ttk.Scrollbar(packaging_log_card, orient=tk.VERTICAL, command=packaging_log_text.yview)
    packaging_log_text.configure(yscrollcommand=packaging_log_scroll.set)
    packaging_log_text.grid(row=0, column=0, sticky="nsew")
    packaging_log_scroll.grid(row=0, column=1, sticky="ns")

    update_packaging_state(Path(packaging_build_var.get()))
    pages["packaging"] = packaging_page

    # Signing Page
    signing_page = ttk.Frame(content, style="Content.TFrame")
    signing_page.columnconfigure(0, weight=1)
    signing_page.rowconfigure(2, weight=1)

    signing_header_row = ttk.Frame(signing_page, style="Content.TFrame")
    signing_header_row.grid(row=0, column=0, sticky="ew")
    signing_header_row.columnconfigure(0, weight=1)
    signing_header_row.columnconfigure(1, weight=0)
    signing_header = ttk.Label(signing_header_row, text="Sign MSIX", style="Header.TLabel")
    signing_header.grid(row=0, column=0, sticky="w")
    signing_hint = ttk.Label(signing_header_row, text="Use osslsigncode to sign an MSIX package.", style="Muted.TLabel")
    signing_hint.grid(row=0, column=1, sticky="e")

    signing_card = create_card(signing_page, "osslsigncode sign")
    signing_card.grid(row=1, column=0, sticky="ew", pady=(12, 8))

    signing_log_card = create_card(signing_page, "Output")
    signing_log_card.grid(row=2, column=0, sticky="nsew")
    signing_log_card.columnconfigure(0, weight=1)
    signing_log_card.rowconfigure(0, weight=1)

    osslsigncode_tool_var = tk.StringVar(value=tool_db.get("osslsigncode", tool_db.get("osssigntiool", "")))
    pfx_path_var = tk.StringVar(value="")
    pfx_password_var = tk.StringVar(value="")
    app_name_var = tk.StringVar(value="")
    input_msix_var = tk.StringVar(value="")
    output_msix_var = tk.StringVar(value="")
    pfx_subject_var = tk.StringVar(value="CN=MyApp")

    def browse_osslsigncode():
        path = filedialog.askopenfilename()
        if path:
            osslsigncode_tool_var.set(path)
            _remember_tool_path("osslsigncode", path)

    def browse_pfx():
        path = filedialog.askopenfilename(filetypes=[("PFX certificate", "*.pfx"), ("All files", "*.*")])
        if path:
            pfx_path_var.set(path)

    def browse_input_msix():
        path = filedialog.askopenfilename(filetypes=[("MSIX packages", "*.msix"), ("All files", "*.*")])
        if path:
            input_msix_var.set(path)
            if not output_msix_var.get().strip():
                input_path = Path(path)
                output_msix_var.set(str(input_path.with_name(f"{input_path.stem}-signed.msix")))

    def browse_output_msix():
        initial_dir = str(Path(input_msix_var.get()).parent) if input_msix_var.get().strip() else str(Path.cwd())
        initial_file = Path(output_msix_var.get()).name if output_msix_var.get().strip() else ""
        path = filedialog.asksaveasfilename(
            defaultextension=".msix",
            initialdir=initial_dir,
            initialfile=initial_file,
            filetypes=[("MSIX packages", "*.msix"), ("All files", "*.*")]
        )
        if path:
            output_msix_var.set(path)

    def append_signing_log(message: str):
        signing_log_text.configure(state="normal")
        signing_log_text.insert(tk.END, message.rstrip() + "\n")
        signing_log_text.see(tk.END)
        signing_log_text.configure(state="disabled")

    def create_pfx():
        pfx_window = tk.Toplevel(root)
        pfx_window.title("Create PFX (OpenSSL)")
        pfx_window.geometry("620x360")
        pfx_window.resizable(True, False)

        frame = ttk.Frame(pfx_window, padding=16, style="Content.TFrame")
        frame.pack(fill=tk.BOTH, expand=True)
        frame.columnconfigure(1, weight=1)

        key_var = tk.StringVar(value="")
        cert_var = tk.StringVar(value="")
        days_var = tk.StringVar(value="365")
        subject_var = tk.StringVar(value=pfx_subject_var.get().strip() or "CN=Unknown")
        pfx_out_var = tk.StringVar(value="")
        password_var = tk.StringVar(value=pfx_password_var.get())

        def browse_path(var, ext_label):
            path = filedialog.asksaveasfilename(
                defaultextension=ext_label,
                filetypes=[(f"{ext_label.upper()} file", f"*{ext_label}"), ("All files", "*.*")]
            )
            if path:
                var.set(path)

        add_row(frame, 0, "Key output", ttk.Entry(frame, textvariable=key_var), ttk.Button(frame, text="Browse", style="Ghost.TButton", command=lambda: browse_path(key_var, ".pem")))
        add_row(frame, 1, "Cert output", ttk.Entry(frame, textvariable=cert_var), ttk.Button(frame, text="Browse", style="Ghost.TButton", command=lambda: browse_path(cert_var, ".pem")))
        add_row(frame, 2, "Days", ttk.Entry(frame, textvariable=days_var))
        add_row(frame, 3, "Subject", ttk.Entry(frame, textvariable=subject_var))
        add_row(frame, 4, "PFX output", ttk.Entry(frame, textvariable=pfx_out_var), ttk.Button(frame, text="Browse", style="Ghost.TButton", command=lambda: browse_path(pfx_out_var, ".pfx")))
        add_row(frame, 5, "PFX password", ttk.Entry(frame, textvariable=password_var, show="*"))

        command_preview = tk.StringVar(value="openssl req -x509 -newkey rsa:2048 -nodes -keyout ...")
        ttk.Label(frame, textvariable=command_preview, style="Muted.TLabel").grid(row=6, column=0, columnspan=3, sticky="w", pady=(8, 6))

        def update_preview(*_):
            command_preview.set(
                "openssl req -x509 -newkey rsa:2048 -nodes "
                f"-keyout {key_var.get().strip() or 'key.pem'} "
                f"-out {cert_var.get().strip() or 'cert.pem'} "
                f"-days {days_var.get().strip() or '365'} "
                f"-subj \"/{subject_var.get().strip() or 'CN=Unknown'}\" "
                "&& openssl pkcs12 -export "
                f"-out {pfx_out_var.get().strip() or 'cert.pfx'} "
                f"-inkey {key_var.get().strip() or 'key.pem'} "
                f"-in {cert_var.get().strip() or 'cert.pem'} "
                f"-passout pass:{password_var.get().strip() or 'password'}"
            )

        for var in (key_var, cert_var, days_var, subject_var, pfx_out_var, password_var):
            var.trace_add("write", update_preview)
        update_preview()

        actions = ttk.Frame(frame, style="Content.TFrame")
        actions.grid(row=7, column=0, columnspan=3, sticky="e", pady=(8, 0))

        def run_create():
            if not key_var.get().strip():
                messagebox.showerror("Missing key output", "Choose a key output path.")
                return
            if not cert_var.get().strip():
                messagebox.showerror("Missing cert output", "Choose a cert output path.")
                return
            if not pfx_out_var.get().strip():
                messagebox.showerror("Missing PFX output", "Choose a PFX output path.")
                return
            try:
                days = int(days_var.get().strip() or "365")
            except ValueError:
                messagebox.showerror("Invalid days", "Days must be a number.")
                return
            key_path = Path(key_var.get().strip()).expanduser().resolve()
            cert_path = Path(cert_var.get().strip()).expanduser().resolve()
            pfx_path = Path(pfx_out_var.get().strip()).expanduser().resolve()
            subject = subject_var.get().strip()
            password = password_var.get()
            ok, output = _create_pfx_with_openssl(key_path, cert_path, days, subject, pfx_path, password)
            if output:
                append_signing_log(output)
                print(output)
            if ok:
                pfx_path_var.set(str(pfx_path))
                pfx_password_var.set(password)
                pfx_subject_var.set(subject)
                messagebox.showinfo("PFX created", f"PFX created:\n{pfx_path}")
                pfx_window.destroy()
            else:
                messagebox.showerror("PFX creation failed", output or "Failed to create PFX.")

        ttk.Button(actions, text="Create", style="Accent.TButton", command=run_create).grid(row=0, column=0, padx=(0, 8))
        ttk.Button(actions, text="Cancel", style="Ghost.TButton", command=pfx_window.destroy).grid(row=0, column=1)

    def sign_msix():
        tool_path = osslsigncode_tool_var.get().strip()
        if tool_path:
            _remember_tool_path("osslsigncode", tool_path)
        cert_text = pfx_path_var.get().strip()
        input_text = input_msix_var.get().strip()
        output_text = output_msix_var.get().strip()
        app_name = app_name_var.get().strip()
        password = pfx_password_var.get()
        if not cert_text:
            messagebox.showerror("Missing PFX", "Select a .pfx certificate file.")
            return
        if not input_text:
            messagebox.showerror("Missing input", "Select an input .msix file.")
            return
        if not output_text:
            messagebox.showerror("Missing output", "Select an output .msix file.")
            return
        if not app_name:
            messagebox.showerror("Missing name", "Enter the app name for signing.")
            return
        if not password:
            messagebox.showerror("Missing password", "Enter the PFX password.")
            return
        cert_path = Path(cert_text).expanduser().resolve()
        input_path = Path(input_text).expanduser().resolve()
        output_path = Path(output_text).expanduser().resolve()
        ok, output = _run_osslsigncode(tool_path, cert_path, password, app_name, input_path, output_path)
        if output:
            append_signing_log(output)
            print(output)
        if ok:
            messagebox.showinfo("MSIX signed", f"Signed MSIX:\n{output_path}")
        else:
            messagebox.showerror("Signing failed", output or "osslsigncode failed.")

    add_row(signing_card, 0, "osslsigncode path", ttk.Entry(signing_card, textvariable=osslsigncode_tool_var), ttk.Button(signing_card, text="Browse", style="Ghost.TButton", command=browse_osslsigncode))
    add_row(signing_card, 1, "PFX file", ttk.Entry(signing_card, textvariable=pfx_path_var), ttk.Button(signing_card, text="Browse", style="Ghost.TButton", command=browse_pfx))
    add_row(signing_card, 2, "PFX password", ttk.Entry(signing_card, textvariable=pfx_password_var, show="*"))
    add_row(signing_card, 3, "Certificate subject", ttk.Entry(signing_card, textvariable=pfx_subject_var))
    add_row(signing_card, 4, "App name", ttk.Entry(signing_card, textvariable=app_name_var))
    add_row(signing_card, 5, "Input MSIX", ttk.Entry(signing_card, textvariable=input_msix_var), ttk.Button(signing_card, text="Browse", style="Ghost.TButton", command=browse_input_msix))
    add_row(signing_card, 6, "Output MSIX", ttk.Entry(signing_card, textvariable=output_msix_var), ttk.Button(signing_card, text="Browse", style="Ghost.TButton", command=browse_output_msix))

    signing_actions = ttk.Frame(signing_card, style="Content.TFrame")
    signing_actions.grid(row=7, column=0, columnspan=3, sticky="e", pady=(6, 0))
    ttk.Button(signing_actions, text="Create PFX", style="Ghost.TButton", command=create_pfx).grid(row=0, column=0, padx=(0, 8))
    ttk.Button(signing_actions, text="Sign MSIX", style="Accent.TButton", command=sign_msix).grid(row=0, column=1, padx=(0, 8))
    ttk.Button(signing_actions, text="Get osslsigncode", style="Ghost.TButton", command=lambda: webbrowser.open("https://github.com/mtrojnar/osslsigncode")).grid(row=0, column=2)

    signing_log_text = tk.Text(signing_log_card, height=10, background=colors["panel"], foreground=colors["text"], insertbackground=colors["text"], borderwidth=0)
    signing_log_text.configure(state="disabled")
    signing_log_scroll = ttk.Scrollbar(signing_log_card, orient=tk.VERTICAL, command=signing_log_text.yview)
    signing_log_text.configure(yscrollcommand=signing_log_scroll.set)
    signing_log_text.grid(row=0, column=0, sticky="nsew")
    signing_log_scroll.grid(row=0, column=1, sticky="ns")

    pages["signing"] = signing_page

    add_nav_button("create", "New Project")
    add_nav_button("editor", "Editor")
    add_nav_button("runner", "Runner / Installer")
    add_nav_button("packaging", "Packaging")
    add_nav_button("signing", "Signing")

    show_page("create")

    root.mainloop()

def edit_project_config_gui(config_path: Path, parent=None) -> None:
    data = _load_config(config_path)
    project_dir = _resolve_project_dir(config_path, data)
    manifest_paths = _get_manifest_paths(project_dir)
    current_caps = set()
    if manifest_paths:
        current_caps = _read_manifest_capabilities(manifest_paths[0])

    try:
        import tkinter as tk
        from tkinter import ttk, filedialog, messagebox
    except Exception as exc:
        _error(f"Failed to start GUI: {exc}")
        sys.exit(1)

    owning_root = parent is None
    root = tk.Tk() if owning_root else tk.Toplevel(parent)
    root.title("MinGW WinRT Project Editor")
    root.geometry("800x760")
    root.resizable(True, True)
    _apply_vs_style(root)

    header = ttk.Label(root, text="Edit MinGW WinRT project", font=("Segoe UI", 14, "bold"))
    header.pack(pady=(16, 6))
    subtitle = ttk.Label(root, text=str(config_path))
    subtitle.pack(pady=(0, 10))

    canvas = tk.Canvas(root, highlightthickness=0)
    scrollbar = ttk.Scrollbar(root, orient=tk.VERTICAL, command=canvas.yview)
    canvas.configure(yscrollcommand=scrollbar.set)

    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

    frame = ttk.Frame(canvas, padding=16)
    frame_id = canvas.create_window((0, 0), window=frame, anchor="nw")

    def _on_frame_configure(event):
        canvas.configure(scrollregion=canvas.bbox("all"))

    def _on_canvas_configure(event):
        canvas.itemconfig(frame_id, width=event.width)

    frame.bind("<Configure>", _on_frame_configure)
    canvas.bind("<Configure>", _on_canvas_configure)

    def add_row(row, label_text, widget, button=None):
        label = ttk.Label(frame, text=label_text)
        label.grid(row=row, column=0, sticky="w", pady=6)
        widget.grid(row=row, column=1, sticky="ew", padx=(8, 0), pady=6)
        if button is not None:
            button.grid(row=row, column=2, sticky="e", padx=(8, 0), pady=6)

    frame.columnconfigure(1, weight=1)

    name_var = tk.StringVar(value=data.get('name', project_dir.name))
    name_entry = ttk.Entry(frame, textvariable=name_var, state="disabled")

    project_dir_var = tk.StringVar(value=str(project_dir))
    project_dir_entry = ttk.Entry(frame, textvariable=project_dir_var, state="disabled")

    arch_var = tk.StringVar(value=data.get('arch', 'x64'))
    arch_combo = ttk.Combobox(frame, textvariable=arch_var, state="readonly")
    arch_combo["values"] = ARCH_CHOICES

    publisher_var = tk.StringVar(value=data.get('publisher', 'CN=Unknown'))
    publisher_entry = ttk.Entry(frame, textvariable=publisher_var)

    resources_var = tk.StringVar(value=data.get('resourcesDir', ''))
    resources_entry = ttk.Entry(frame, textvariable=resources_var)
    resources_button = ttk.Button(frame, text="Browse", command=lambda: resources_var.set(filedialog.askdirectory() or resources_var.get()))

    images = data.get('images', {}) or {}
    icon_var = tk.StringVar(value=images.get('icon', ''))
    icon_entry = ttk.Entry(frame, textvariable=icon_var)
    icon_button = ttk.Button(frame, text="Browse", command=lambda: icon_var.set(filedialog.askopenfilename() or icon_var.get()))

    banner_var = tk.StringVar(value=images.get('banner', ''))
    banner_entry = ttk.Entry(frame, textvariable=banner_var)
    banner_button = ttk.Button(frame, text="Browse", command=lambda: banner_var.set(filedialog.askopenfilename() or banner_var.get()))

    include_msvc_var = tk.BooleanVar(value=bool(data.get('includeMsvcDlls', False)))

    add_row(0, "Project name", name_entry)
    add_row(1, "Project directory", project_dir_entry)
    add_row(2, "Architecture", arch_combo)
    add_row(3, "Publisher", publisher_entry)
    add_row(4, "Resources directory", resources_entry, resources_button)
    add_row(5, "Icon image", icon_entry, icon_button)
    add_row(6, "Banner image", banner_entry, banner_button)
    ttk.Checkbutton(frame, text="Include MSVC DLLs in deps/bin", variable=include_msvc_var).grid(row=7, column=1, sticky="w", pady=(4, 6))

    cap_frame = ttk.Labelframe(frame, text="Capabilities", padding=12)
    cap_frame.grid(row=8, column=0, columnspan=3, sticky="ew", pady=(10, 6))
    cap_frame.columnconfigure(0, weight=1)
    cap_frame.columnconfigure(1, weight=1)

    cap_vars = {}
    caps_list = list(STANDARD_CAPS) + list(RESTRICTED_CAPS)
    for idx, cap in enumerate(caps_list):
        cap_vars[cap] = tk.BooleanVar(value=cap in current_caps)
        row = idx // 2
        col = idx % 2
        ttk.Checkbutton(cap_frame, text=cap, variable=cap_vars[cap]).grid(row=row, column=col, sticky="w", padx=4, pady=2)

    optional_frame = ttk.Labelframe(frame, text="Optional capabilities", padding=12)
    optional_frame.grid(row=9, column=0, columnspan=3, sticky="ew", pady=(6, 6))
    optional_frame.columnconfigure(1, weight=1)

    optional_selected = [cap for cap in OPTIONAL_CAPS if cap in current_caps]
    optional_var = tk.StringVar(value=OPTIONAL_CAPS[0] if OPTIONAL_CAPS else '')
    optional_combo = ttk.Combobox(optional_frame, textvariable=optional_var, state="readonly")
    optional_combo["values"] = OPTIONAL_CAPS

    optional_list = tk.Listbox(optional_frame, height=4)
    for cap in optional_selected:
        optional_list.insert(tk.END, cap)

    def add_optional():
        cap = optional_var.get()
        if not cap:
            return
        items = set(optional_list.get(0, tk.END))
        if cap not in items:
            optional_list.insert(tk.END, cap)

    def remove_optional():
        selection = optional_list.curselection()
        if not selection:
            return
        for idx in reversed(selection):
            optional_list.delete(idx)

    ttk.Label(optional_frame, text="Add capability").grid(row=0, column=0, sticky="w", pady=4)
    optional_combo.grid(row=0, column=1, sticky="ew", padx=(8, 0), pady=4)
    ttk.Button(optional_frame, text="Add", command=add_optional).grid(row=0, column=2, sticky="e", padx=(8, 0), pady=4)
    ttk.Label(optional_frame, text="Selected").grid(row=1, column=0, sticky="nw", pady=4)
    optional_list.grid(row=1, column=1, sticky="ew", padx=(8, 0), pady=4)
    ttk.Button(optional_frame, text="Remove", command=remove_optional).grid(row=1, column=2, sticky="ne", padx=(8, 0), pady=4)

    button_frame = ttk.Frame(root, padding=(16, 0, 16, 16))
    button_frame.pack(fill=tk.X)
    button_frame.columnconfigure(0, weight=1)

    def on_save():
        updated = dict(data)
        updated['name'] = name_var.get()
        updated['arch'] = arch_var.get()
        updated['publisher'] = publisher_var.get().strip() or 'CN=Unknown'
        updated['resourcesDir'] = resources_var.get().strip()
        updated['projectDir'] = project_dir_var.get()
        updated['images'] = {
            'icon': icon_var.get().strip(),
            'banner': banner_var.get().strip()
        }
        updated['includeMsvcDlls'] = bool(include_msvc_var.get())

        selected_caps = {cap for cap, var in cap_vars.items() if var.get()}
        selected_caps.update(optional_list.get(0, tk.END))
        updated['capabilities'] = sorted(selected_caps)

        _save_config(config_path, updated)
        _update_metadata(project_dir, updated['arch'])
        _update_manifest_publisher(project_dir, updated['publisher'])
        if manifest_paths:
            _update_manifest_capabilities(project_dir, set(selected_caps))
        _sync_images(project_dir, updated['resourcesDir'], updated['images']['icon'], updated['images']['banner'])
        if updated['includeMsvcDlls'] and project_dir.exists():
            _ensure_deps_layout(project_dir)
            _copy_msvc_dlls(project_dir, updated['arch'])

        messagebox.showinfo("Saved", f"Updated config: {config_path}")
        root.destroy()

    ttk.Button(button_frame, text="Save", command=on_save).grid(row=0, column=1, sticky="e")
    ttk.Button(button_frame, text="Cancel", command=root.destroy).grid(row=0, column=2, sticky="e", padx=(8, 0))

    if owning_root:
        root.mainloop()

def _run_makemsix_cli(argv) -> None:
    parser = argparse.ArgumentParser(
        description="Package MSIX using makemsix (requires pack-capable build)."
    )
    parser.add_argument("build_dir", help="Directory containing AppxManifest.xml")
    parser.add_argument("-o", "--output", default="", help="Output .msix path (optional)")
    parser.add_argument("--makemsix", default="", help="Path to makemsix executable (optional)")
    args = parser.parse_args(argv)

    build_dir = Path(args.build_dir).expanduser().resolve()
    manifest_path = _find_appx_manifest(build_dir)
    if not manifest_path:
        _error(f"AppxManifest.xml not found in {build_dir}")
        sys.exit(1)

    output_path = Path(args.output).expanduser().resolve() if args.output else _suggest_msix_output(build_dir)
    tool_db = _load_tool_db()
    tool_path = args.makemsix or tool_db.get("makemsix", "")
    if args.makemsix:
        _remember_tool_path("makemsix", args.makemsix)

    ok, output = _run_makemsix(tool_path, build_dir, output_path)
    if output:
        print(output)
    if ok:
        _success(f"MSIX created: {output_path}")
        return
    _error("makemsix failed.")
    sys.exit(1)

def _run_install_cli(argv) -> None:
    parser = argparse.ArgumentParser(
        description="Run/register loose builds or install MSIX/AppX packages.",
        epilog=(
            "Remote deploy requires --json with ip/username/password under devicePortal.\n"
            "Loose remote deploy requires a UNC path (\\\\host\\share\\path)."
        ),
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument("build_dir", help="Directory containing AppxManifest.xml")
    parser.add_argument("--no-launch", action="store_true", help="Do not launch after registering")
    parser.add_argument("--remote", action="store_true", help="Deploy to a remote device portal")
    parser.add_argument("--json", default="", help="Path to mingw_winrt.json with device portal credentials")
    parser.add_argument("--logs", action="store_true", help="Print recent runtime logs after install/run")
    parser.add_argument("--debug", action="store_true", help="Print recent debug output (Windows only)")
    parser.add_argument("--crashes", action="store_true", help="Print recent crash events (Windows only)")
    parser.add_argument("--minutes", type=int, default=10, help="Minutes to look back for logs (default 10)")
    args = parser.parse_args(argv)

    build_dir = Path(args.build_dir).expanduser().resolve()
    if build_dir.is_file():
        if build_dir.suffix.lower() not in ('.msix', '.msixbundle', '.appx', '.appxbundle'):
            _error("Unsupported package type. Use .msix, .msixbundle, .appx, or .appxbundle.")
            sys.exit(1)
        if args.remote:
            if not args.json:
                _error("--json is required for remote deploy.")
                sys.exit(1)
            json_path = Path(args.json).expanduser().resolve()
            if not json_path.exists():
                _error(f"Config not found: {json_path}")
                sys.exit(1)
            portal = _load_device_portal_from_json(json_path)
            ip = portal.get("ip", "")
            username = portal.get("username", "")
            password = portal.get("password", "")
            if not ip or not username or not password:
                _error("JSON must include ip, username, and password.")
                sys.exit(1)
            _info("Deploying MSIX package to device portal...")
            ok, output = _deploy_msix_remote(build_dir, ip, username, password)
            if output:
                print(output)
            if ok:
                _success("Remote install accepted.")
                return
            _error("Remote MSIX deploy failed.")
            sys.exit(1)

        _info("Installing MSIX locally...")
        ok, output = _install_msix_local(build_dir)
        if output:
            print(output)
        if ok:
            _success("Install completed.")
            return
        _error("MSIX install failed.")
        sys.exit(1)
    manifest_path = _find_appx_manifest(build_dir)
    if not manifest_path:
        _error(f"AppxManifest.xml not found in {build_dir}")
        sys.exit(1)

    if args.remote:
        if not args.json:
            _error("--json is required for remote deploy.")
            sys.exit(1)
        json_path = Path(args.json).expanduser().resolve()
        if not json_path.exists():
            _error(f"Config not found: {json_path}")
            sys.exit(1)
        portal = _load_device_portal_from_json(json_path)
        ip = portal.get("ip", "")
        username = portal.get("username", "")
        password = portal.get("password", "")
        if not ip or not username or not password:
            _error("JSON must include ip, username, and password.")
            sys.exit(1)
        share_path = str(build_dir)
        if not (share_path.startswith("\\\\") or share_path.startswith("//")):
            _error("Remote deploy requires a UNC path (\\\\host\\share\\path).")
            sys.exit(1)
        _info("Deploying loose folder to device portal...")
        ok, output = _deploy_loose_remote(share_path, ip, username, password)
        if output:
            print(output)
        if ok:
            _success("Remote deploy accepted.")
            return
        _error("Remote deploy failed.")
        sys.exit(1)

    _info("Registering AppxManifest.xml locally...")
    ok, output = _register_appx(manifest_path)
    if output:
        print(output)
    if not ok:
        _error("Registration failed.")
        sys.exit(1)
    _success("Registration completed.")

    identity_name, app_id = _read_manifest_identity(manifest_path)

    if args.no_launch:
        if args.logs or args.debug or args.crashes:
            if args.logs:
                logs = _collect_runtime_logs(identity_name, minutes=args.minutes)
                if logs:
                    print("\n=== Runtime Logs ===")
                    print(logs)
            if args.debug:
                debug_logs = _collect_debug_output(identity_name, minutes=args.minutes)
                if debug_logs:
                    print("\n=== Debug Output ===")
                    print(debug_logs)
            if args.crashes:
                crash_logs = _collect_crash_logs(identity_name, minutes=max(args.minutes, 10))
                if crash_logs:
                    print("\n=== Crash Logs ===")
                    print(crash_logs)
        return

    _info("Launching app...")
    launch_ok, launch_output = _launch_app(identity_name, app_id)
    if launch_output:
        print(launch_output)
    if not launch_ok:
        _error("Failed to launch app.")
        sys.exit(1)

    if not (args.logs or args.debug or args.crashes):
        logs = _collect_runtime_logs(identity_name, minutes=10)
        if logs:
            print("\n=== Runtime Logs ===")
            print(logs)
        return

    if args.logs:
        logs = _collect_runtime_logs(identity_name, minutes=args.minutes)
        if logs:
            print("\n=== Runtime Logs ===")
            print(logs)

    if args.debug:
        debug_logs = _collect_debug_output(identity_name, minutes=args.minutes)
        if debug_logs:
            print("\n=== Debug Output ===")
            print(debug_logs)

    if args.crashes:
        crash_logs = _collect_crash_logs(identity_name, minutes=max(args.minutes, 10))
        if crash_logs:
            print("\n=== Crash Logs ===")
            print(crash_logs)

def main():
    parser = argparse.ArgumentParser(description='Generate MinGW UWP projects (loose files)')
    parser.add_argument('type', choices=['library', 'console', 'xaml', 'corewindow'], help='Project type')
    parser.add_argument('name', help='Project name')
    parser.add_argument('--template-dir', default=str(Path(__file__).parent.parent / 'templates'), help='Templates directory')
    parser.add_argument('--output-dir', default='.', help='Output directory (will create a folder with project name)')
    parser.add_argument('--arch', default='x64', help='Target architecture (x64/x86/arm64/arm)')
    parser.add_argument('--publisher', default='CN=Unknown', help='Publisher CN for manifest')
    parser.add_argument('--overwrite', action='store_true', help='Overwrite output directory if it exists')
    parser.add_argument('--include-msvc-dlls', action='store_true', help='Copy MSVC runtime DLLs into deps/bin')

    force_cli = '--cli' in sys.argv
    if force_cli:
        sys.argv.remove('--cli')
    if '--gui' in sys.argv:
        sys.argv.remove('--gui')

    if len(sys.argv) == 1:
        repo_root = Path(__file__).parent.parent
        images_dir = repo_root / 'Images'
        launch_gui(
            default_template_dir=Path(parser.get_default('template_dir')).expanduser().resolve(),
            default_output_dir=Path(parser.get_default('output_dir')).expanduser().resolve(),
            default_arch=parser.get_default('arch'),
            default_publisher=parser.get_default('publisher'),
            images_dir=images_dir,
        )
        return

    if len(sys.argv) >= 2:
        first = sys.argv[1].lower()
        if first == "makemsix":
            if len(sys.argv) < 3:
                _error("Missing build directory for makemsix.")
                sys.exit(1)
            _run_makemsix_cli(sys.argv[2:])
            return
        if first in RUN_ALIASES:
            if len(sys.argv) < 3:
                _error("Missing build directory for run/install.")
                sys.exit(1)
            _run_install_cli(sys.argv[2:])
            return
        if len(sys.argv) == 2 and Path(sys.argv[1]).is_dir():
            _run_install_cli(sys.argv[1:])
            return
        if len(sys.argv) >= 3 and Path(sys.argv[2]).is_dir() and first not in ('library', 'console', 'xaml', 'corewindow'):
            _run_install_cli(sys.argv[2:])
            return

    json_args = [arg for arg in sys.argv[1:] if arg.lower().endswith('.json')]
    if json_args:
        maybe_config = Path(json_args[0])
        if maybe_config.exists():
            if force_cli:
                edit_project_config(maybe_config.resolve())
            else:
                edit_project_config_gui(maybe_config.resolve())
            return

    args = parser.parse_args()

    repo_root = Path(__file__).parent.parent
    template_dir = Path(args.template_dir)
    out_dir = Path(args.output_dir).resolve() / args.name
    images_dir = repo_root / 'Images'

    generate_project(template_dir, args.type, args.name, out_dir, args.arch, args.publisher, images_dir, args.overwrite, args.include_msvc_dlls)

if __name__ == '__main__':
    main()
