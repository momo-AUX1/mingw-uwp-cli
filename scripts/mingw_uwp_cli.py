#!/usr/bin/env python3
import argparse
import shutil
import uuid
import tempfile
import os
import subprocess
import ctypes
import csv
from datetime import datetime, timedelta
import time
import base64
import ssl
import urllib.request
import urllib.error
import urllib.parse
import webbrowser
import threading
import socket
import http.client
from pathlib import Path
import re
import json
import sys
from typing import Optional
from xml.etree import ElementTree as ET

try:
    from PIL import Image
except Exception:
    Image = None

__AUTHOR__ = "Momo-AUX1"
__VERSION__ = "1.0.0"
__GIT_URL__ = "https://github.com/momo-AUX1/mingw-uwp-cli"

TEXT_EXTENSIONS = {'.txt', '.in', '.xml', '.xaml', '.cpp', '.h', '.hpp', '.c', '.cmake', 'CMakeLists.txt', '.md'}
DEFAULT_CONFIG_NAME = 'mingw_winrt.json'
ARCH_CHOICES = ('x64', 'x86', 'arm64', 'arm')
MSVC_DLLS = (
    'msvcp140_app.dll',
    'vcruntime140_app.dll',
    'vcruntime140_1_app.dll',
    'dxil.dll',
    'vccorlib140_app.dll'
)
WINDOWS = os.name == 'nt'
RUN_ALIASES = {'run', 'install', 'runner', 'installer', 'deploy'}
DEVICE_PORTAL_KEY = 'devicePortal'
REPO_ROOT = Path(__file__).parent.parent
TOOL_DB_PATH = Path(__file__).with_name("db.json")
NAMESPACE_URIS = {
    'foundation': 'http://schemas.microsoft.com/appx/manifest/foundation/windows10',
    'uap': 'http://schemas.microsoft.com/appx/manifest/uap/windows10',
    'rescap': 'http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities',
}
CAPABILITY_DEFS = {
    'internetClient': 'foundation',
    'internetClientServer': 'foundation',
    'privateNetworkClientServer': 'foundation',
    'enterpriseAuthentication': 'foundation',
    'sharedUserCertificates': 'foundation',
    'removableStorage': 'uap',
    'documentsLibrary': 'uap',
    'picturesLibrary': 'uap',
    'videosLibrary': 'uap',
    'musicLibrary': 'uap',
    'location': 'uap',
    'microphone': 'uap',
    'webcam': 'uap',
    'userAccountInformation': 'uap',
    'contacts': 'uap',
    'appointments': 'uap',
    'codeGeneration': 'rescap',
    'broadFileSystemAccess': 'rescap',
    'runFullTrust': 'rescap',
}
STANDARD_CAPS = (
    'internetClient',
    'internetClientServer',
    'privateNetworkClientServer',
    'removableStorage',
    'documentsLibrary',
    'picturesLibrary',
    'videosLibrary',
    'musicLibrary',
    'location',
    'microphone',
    'webcam',
)
RESTRICTED_CAPS = (
    'codeGeneration',
    'broadFileSystemAccess',
    'runFullTrust',
)
OPTIONAL_CAPS = (
    'enterpriseAuthentication',
    'sharedUserCertificates',
    'userAccountInformation',
    'contacts',
    'appointments',
)

def _supports_color() -> bool:
    if not sys.stdout.isatty():
        return False
    term = os.environ.get('TERM', '')
    return term != 'dumb'

def _color(text: str, code: str) -> str:
    if not _supports_color():
        return text
    return f"\033[{code}m{text}\033[0m"

def _info(text: str) -> None:
    print(_color(text, '36'))

def _success(text: str) -> None:
    print(_color(text, '32'))

def _warn(text: str) -> None:
    print(_color(text, '33'))

def _error(text: str) -> None:
    print(_color(text, '31'))

def sanitize_namespace(name: str) -> str:
    s = re.sub(r'[^0-9A-Za-z_]', '', name)
    if not s:
        return 'App'
    if s[0].isdigit():
        s = '_' + s
    return s

def is_text_file(path: Path) -> bool:
    ext = path.suffix
    if path.name == 'CMakeLists.txt':
        return True
    return ext in TEXT_EXTENSIONS

def replace_in_file(path: Path, replacements):
    try:
        text = path.read_text(encoding='utf-8')
    except Exception:
        return
    original = text
    for old, new in replacements.items():
        text = text.replace(old, new)
    guid_regex = re.compile(r'[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}')
    def guid_replacer(match):
        return str(uuid.uuid4())
    text = guid_regex.sub(guid_replacer, text)
    if text != original:
        path.write_text(text, encoding='utf-8')

def _write_project_readme(out_dir: Path, project_name: str, project_type: str) -> None:
    extra_install = ""
    if project_type in ('xaml', 'corewindow'):
        extra_install = "\nFast register (dev loop):\n\n```powershell\n" \
                        "powershell.exe -Command Add-AppxPackage -Register .\\AppxManifest.xml\n" \
                        "```\n"

    readme = fr"""# {project_name}

Generated by the MinGW WinRT project generator.

## Build

```powershell
cmake -S . -B build
cmake --build build
```

## Package (Appx/MSIX)

```powershell
cmake --build build --target appx
cmake --build build --target msix
```

Outputs will be in `build/{project_name}.appx` or `build/{project_name}.msix`.

## Install

```powershell
powershell.exe -NoProfile -ExecutionPolicy Bypass -File ./install.ps1 -Package ./build/{project_name}.appx
```

If you have the Windows 10/11 SDK installed, `makeappx.exe` is used for packaging.
{extra_install}

## Troubleshooting (macOS/Linux cross-build)

If you build with MinGW GCC 15 on macOS/Linux and see a coroutine_handle error in WinRT headers, reconfigure with:

```powershell
cmake -S . -B build -DMINGW_WINRT_COROUTINE_ALIAS_FIX=ON
```

## Complete MacOS cross compile example:

```powershell
cmake -S . -B build \
-DCMAKE_SYSTEM_NAME=Windows \
-DCMAKE_C_COMPILER=/opt/homebrew/bin/x86_64-w64-mingw32-gcc \
-DCMAKE_CXX_COMPILER=/opt/homebrew/bin/x86_64-w64-mingw32-g++ \
-DMINGW_USE_WINRT=ON \
-DMINGW_WINRT_FORCE_FROZEN_SDK=ON \
-DMINGW_WINRT_SYSROOT=/opt/homebrew/opt/mingw-w64/x86_64-w64-mingw32/sys-root/mingw \
-DMINGW_WINRT_COROUTINE_ALIAS_FIX=ON \
-DAPPX_ARCH_OVERRIDE=x64
```

This applies a build-directory-only workaround. Windows builds do not need it.
"""
    (out_dir / 'README.md').write_text(readme, encoding='utf-8')

def _write_install_script(out_dir: Path, project_name: str) -> None:
    script = fr"""param(
    [string]$Package = ""
)

$ErrorActionPreference = "Stop"

if (-not $Package) {{
    if (Test-Path "./build/{project_name}.msix") {{
        $Package = "./build/{project_name}.msix"
    }} elseif (Test-Path "./build/{project_name}.appx") {{
        $Package = "./build/{project_name}.appx"
    }} else {{
        Write-Host "Package not found. Build and package first." -ForegroundColor Red
        exit 1
    }}
}}

Write-Host "Installing $Package" -ForegroundColor Cyan
Add-AppxPackage -Path $Package
"""
    (out_dir / 'install.ps1').write_text(script, encoding='utf-8')

def _ensure_deps_layout(out_dir: Path) -> None:
    for sub in ('bin', 'include', 'lib'):
        (out_dir / 'deps' / sub).mkdir(parents=True, exist_ok=True)

def _arch_folder(arch: str) -> str:
    return {
        'x64': 'x64',
        'x86': 'x86',
        'arm64': 'arm64',
        'arm': 'arm',
    }.get(arch, arch)

def _find_msvc_redist_dir(arch: str) -> Optional[Path]:
    repo_msvc = REPO_ROOT / 'MSVC'
    if repo_msvc.exists():
        return repo_msvc
    return None

def _copy_msvc_dlls(out_dir: Path, arch: str) -> None:
    redist_dir = _find_msvc_redist_dir(arch)
    if not redist_dir:
        _warn("⚠️  MSVC redist not found; skipping MSVC DLL copy.")
        return
    dest = out_dir / 'deps' / 'bin'
    dest.mkdir(parents=True, exist_ok=True)
    any_copied = False
    for dll in MSVC_DLLS:
        src = redist_dir / dll
        if src.exists():
            shutil.copy2(src, dest / dll)
            any_copied = True
        else:
            _warn(f"⚠️  Missing MSVC DLL: {src}")
    if not any_copied:
        _warn(f"⚠️  No specified MSVC DLLs were found in {redist_dir}; nothing was copied.")

def _get_manifest_paths(project_dir: Path) -> list:
    paths = []
    for name in ('AppxManifest.in', 'AppxManifest.xml'):
        path = project_dir / name
        if path.exists():
            paths.append(path)
    return paths

def _local_name(tag: str) -> str:
    if tag.startswith('{'):
        return tag.split('}', 1)[1]
    return tag

def _root_namespace(tag: str) -> str:
    if tag.startswith('{'):
        return tag.split('}', 1)[0].strip('{')
    return ''

def _read_manifest_capabilities(path: Path) -> set:
    try:
        tree = ET.parse(path)
    except Exception:
        return set()
    root = tree.getroot()
    caps = set()
    for elem in root.iter():
        if _local_name(elem.tag) != 'Capability':
            continue
        name = elem.attrib.get('Name')
        if name:
            caps.add(name)
    return caps

def _ensure_ignorable_namespaces(root: ET.Element, prefixes: set) -> None:
    existing = root.attrib.get('IgnorableNamespaces', '')
    current = [p for p in existing.split(' ') if p]
    merged = set(current) | set(prefixes)
    if merged:
        root.set('IgnorableNamespaces', ' '.join(sorted(merged)))

def _update_manifest_capabilities_file(path: Path, selected_caps: set) -> None:
    try:
        tree = ET.parse(path)
    except Exception:
        return

    root = tree.getroot()
    foundation_ns = _root_namespace(root.tag) or NAMESPACE_URIS['foundation']

    ET.register_namespace('', foundation_ns)
    ET.register_namespace('uap', NAMESPACE_URIS['uap'])
    ET.register_namespace('rescap', NAMESPACE_URIS['rescap'])

    caps_parent = None
    for child in list(root):
        if _local_name(child.tag) == 'Capabilities':
            caps_parent = child
            break
    if caps_parent is None:
        caps_parent = ET.Element(f"{{{foundation_ns}}}Capabilities")
        root.append(caps_parent)

    known_caps = set(CAPABILITY_DEFS.keys())
    existing_caps = set()

    for parent in root.iter():
        for child in list(parent):
            if _local_name(child.tag) != 'Capability':
                continue
            cap_name = child.attrib.get('Name')
            if not cap_name:
                continue
            existing_caps.add(cap_name)
            if cap_name in known_caps and cap_name not in selected_caps:
                parent.remove(child)

    needed_prefixes = set()
    for cap_name in selected_caps:
        if cap_name in existing_caps:
            continue
        ns_key = CAPABILITY_DEFS.get(cap_name, 'foundation')
        if ns_key == 'foundation':
            ns_uri = foundation_ns
        else:
            ns_uri = NAMESPACE_URIS.get(ns_key, foundation_ns)
            needed_prefixes.add(ns_key)
        cap_el = ET.Element(f"{{{ns_uri}}}Capability")
        cap_el.set('Name', cap_name)
        caps_parent.append(cap_el)

    if needed_prefixes:
        _ensure_ignorable_namespaces(root, needed_prefixes)

    tree.write(path, encoding='utf-8', xml_declaration=True)

def _update_manifest_capabilities(project_dir: Path, selected_caps: set) -> None:
    for path in _get_manifest_paths(project_dir):
        _update_manifest_capabilities_file(path, selected_caps)

def _write_project_config(out_dir: Path, project_type: str, project_name: str, arch: str, publisher: str, include_msvc_dlls: bool) -> Path:
    config = {
        'name': project_name,
        'type': project_type,
        'arch': arch,
        'publisher': publisher or 'CN=Unknown',
        'projectDir': str(out_dir),
        'resourcesDir': '',
        'images': {
            'icon': '',
            'banner': ''
        },
        DEVICE_PORTAL_KEY: {
            'ip': '',
            'username': '',
            'password': ''
        },
        'capabilities': [],
        'includeMsvcDlls': include_msvc_dlls,
        'version': 1
    }
    config_path = out_dir / DEFAULT_CONFIG_NAME
    config_path.write_text(json.dumps(config, indent=2), encoding='utf-8')
    return config_path

def copy_tree(src: Path, dst: Path, replacements, skip_binary_replace=True):
    for root, dirs, files in os.walk(src):
        rel = Path(root).relative_to(src)
        target_dir = dst.joinpath(rel)
        target_dir.mkdir(parents=True, exist_ok=True)
        for f in files:
            s = Path(root) / f
            d = target_dir / f
            shutil.copy2(s, d)
            if is_text_file(s):
                replace_in_file(d, replacements)

def generate_project(template_dir: Path, project_type: str, project_name: str, out_dir: Path, arch: str, publisher: str, reuse_images: Optional[Path], overwrite: bool, include_msvc_dlls: bool):
    if out_dir.exists() and any(out_dir.iterdir()) and not overwrite:
        raise FileExistsError(f"Output directory {out_dir} exists and is not empty (use --overwrite).")

    tmp = Path(tempfile.mkdtemp(prefix='mingw_uwp_'))
    try:
        staging = tmp / project_name
        staging.mkdir()

        src_template = template_dir / project_type
        if not src_template.exists():
            raise FileNotFoundError(f"Template for '{project_type}' not found in {template_dir}")

        replacements = {
            '__PROJECT_NAME__': project_name,
            'CoreAppMinGW': project_name,
            '__PROJECT_NAMESPACE__': sanitize_namespace(project_name),
            '__PUBLISHER__': publisher or 'CN=Unknown',
            'CN=Unknown': publisher or 'CN=Unknown'
        }

        copy_tree(src_template, staging, replacements)

        if project_type in ('xaml', 'corewindow') and reuse_images and reuse_images.exists():
            dest_images = staging / 'Images'
            shutil.copytree(reuse_images, dest_images, dirs_exist_ok=True)

        for p in staging.rglob('*'):
            if p.is_file() and is_text_file(p):
                replace_in_file(p, replacements)

        meta = {
            'project': project_name,
            'namespace': sanitize_namespace(project_name),
            'arch': arch,
            'guid_generated': str(uuid.uuid4())
        }
        (staging / 'metadata.json').write_text(json.dumps(meta, indent=2), encoding='utf-8')

        if out_dir.exists() and out_dir.is_dir():
            shutil.rmtree(out_dir)
        shutil.move(str(staging), str(out_dir))
        _ensure_deps_layout(out_dir)
        if include_msvc_dlls:
            _copy_msvc_dlls(out_dir, arch)
        _write_project_config(out_dir, project_type, project_name, arch, publisher, include_msvc_dlls)
        _write_project_readme(out_dir, project_name, project_type)
        _write_install_script(out_dir, project_name)
        _success(f"Project created: {out_dir}")
    finally:
        try:
            if tmp.exists():
                shutil.rmtree(tmp)
        except Exception:
            pass

def _infer_cmake_defaults(cmake_path: Path) -> tuple[str, str]:
    try:
        text = cmake_path.read_text(encoding='utf-8')
    except Exception:
        return "", ""

    project_name = ""
    target_name = ""

    project_match = re.search(r'(?im)^[ \t]*project\s*\(\s*([^\s\)]+)', text)
    if project_match:
        project_name = project_match.group(1).strip().strip('"').strip("'")

    target_match = re.search(r'(?im)^[ \t]*add_executable\s*\(\s*([^\s\)]+)', text)
    if target_match:
        target_name = target_match.group(1).strip().strip('"').strip("'")
        if target_name in ("${PROJECT_NAME}", "PROJECT_NAME") and project_name:
            target_name = project_name

    if not target_name and project_name:
        target_name = project_name

    return project_name, target_name

def _copy_default_images(dest_images: Path) -> None:
    src_images = REPO_ROOT / 'templates' / 'corewindow' / 'Images'
    if not src_images.exists():
        raise FileNotFoundError(f"Default Images not found at {src_images}")
    shutil.copytree(src_images, dest_images, dirs_exist_ok=True)

def _write_port_manifest(manifest_path: Path) -> None:
    manifest = """<?xml version="1.0" encoding="utf-8"?>
<Package
  xmlns="http://schemas.microsoft.com/appx/manifest/foundation/windows10"
  xmlns:uap="http://schemas.microsoft.com/appx/manifest/uap/windows10"
  IgnorableNamespaces="uap">

  <Identity Name="@MINGW_UWP_PACKAGE_NAME@" Publisher="@MINGW_UWP_PUBLISHER@" Version="1.0.0.0" ProcessorArchitecture="@APPX_ARCHITECTURE@" />

  <Properties>
    <DisplayName>@MINGW_UWP_DISPLAY_NAME@</DisplayName>
    <PublisherDisplayName>@MINGW_UWP_DISPLAY_NAME@</PublisherDisplayName>
    <Logo>Images\\StoreLogo.png</Logo>
  </Properties>

  <Dependencies>
    <TargetDeviceFamily Name="Windows.Universal" MinVersion="10.0.17763.0" MaxVersionTested="10.0.22621.0" />
  </Dependencies>

  <Resources>
    <Resource Language="en-us" />
  </Resources>

  <Capabilities>
  </Capabilities>

  <Applications>
    <Application Id="@MINGW_UWP_APP_ID@" Executable="@MINGW_UWP_EXECUTABLE@" EntryPoint="@MINGW_UWP_ENTRYPOINT@">
      <uap:VisualElements
        DisplayName="@MINGW_UWP_DISPLAY_NAME@"
        Description="@MINGW_UWP_DISPLAY_NAME@"
        BackgroundColor="transparent"
        Square150x150Logo="Images\\Square150x150Logo.png"
        Square44x44Logo="Images\\Square44x44Logo.png">
        <uap:DefaultTile Wide310x150Logo="Images\\Wide310x150Logo.png" />
        <uap:SplashScreen Image="Images\\SplashScreen.png" />
      </uap:VisualElements>
    </Application>
  </Applications>
</Package>
"""
    manifest_path.write_text(manifest, encoding='utf-8')

def _write_port_module(module_path: Path, default_package: str, default_publisher: str) -> None:
    template = """
# Made by MinGW UWP CLI v__VERSION__ (__GIT_URL__)
# MinGW UWP port module
# Include this file from your root CMakeLists.txt and call:
#   mingw_uwp_setup(<target>)
#
# Optional overrides:
#   set(MINGW_UWP_ENABLE ON)
#   set(MINGW_UWP_PUBLISHER "CN=YourPublisher")
#   set(MINGW_UWP_PACKAGE_NAME "Your.Package")
#   set(MINGW_UWP_DISPLAY_NAME "Your App")
#   set(MINGW_UWP_NAMESPACE "YourNamespace")
#   set(MINGW_UWP_ENTRYPOINT "YourNamespace.App")
#   set(MINGW_UWP_APP_ID "App")
#   set(MINGW_UWP_USE_DEPS_LIBS ON)
#   set(MINGW_UWP_DEPS_LIBS "foo;bar")

include(CheckCXXSourceCompiles)

option(MINGW_UWP_ENABLE "Enable MinGW UWP support" OFF)

option(MINGW_WINRT_COROUTINE_ALIAS_FIX "Patch C++/WinRT coroutine alias for GCC/MinGW on non-Windows hosts" OFF)

set(APPX_ARCH_OVERRIDE "" CACHE STRING "Force Appx architecture (x64/x86/arm64/arm) for cross-compiling")

set(_MINGW_UWP_ROOT "${CMAKE_CURRENT_LIST_DIR}")

set(MINGW_UWP_PUBLISHER "__DEFAULT_PUBLISHER__" CACHE STRING "Publisher CN for Appx manifest")
set(MINGW_UWP_PACKAGE_NAME "__DEFAULT_PACKAGE_NAME__" CACHE STRING "Package name for Appx manifest")
set(MINGW_UWP_DISPLAY_NAME "__DEFAULT_PACKAGE_NAME__" CACHE STRING "Display name for Appx manifest")
set(MINGW_UWP_ENTRYPOINT "" CACHE STRING "EntryPoint (namespace.class) for Appx manifest")
set(MINGW_UWP_APP_ID "App" CACHE STRING "Application Id for Appx manifest")
set(MINGW_UWP_USE_DEPS_LIBS OFF CACHE BOOL "Auto-link libraries from deps/lib")
set(MINGW_UWP_DEPS_LIBS "" CACHE STRING "Explicit deps libs to link (semicolon-separated)")

function(_mingw_uwp_setup_impl target)
  if(NOT TARGET ${target})
    message(FATAL_ERROR "mingw_uwp_setup: target '${target}' not found.")
  endif()

  if(APPX_ARCH_OVERRIDE)
    string(TOLOWER "${APPX_ARCH_OVERRIDE}" _appx_arch_override)
    if(_appx_arch_override STREQUAL "amd64" OR _appx_arch_override STREQUAL "x64")
      set(APPX_ARCHITECTURE "x64")
      set(CMAKE_SYSTEM_PROCESSOR "AMD64" CACHE STRING "Forced for workaround" FORCE)
    elseif(_appx_arch_override STREQUAL "x86")
      set(APPX_ARCHITECTURE "x86")
      set(CMAKE_SYSTEM_PROCESSOR "x86" CACHE STRING "Forced for workaround" FORCE)
    elseif(_appx_arch_override STREQUAL "arm64")
      set(APPX_ARCHITECTURE "arm64")
      set(CMAKE_SYSTEM_PROCESSOR "ARM64" CACHE STRING "Forced for workaround" FORCE)
    elseif(_appx_arch_override STREQUAL "arm")
      set(APPX_ARCHITECTURE "arm")
      set(CMAKE_SYSTEM_PROCESSOR "ARM" CACHE STRING "Forced for workaround" FORCE)
    else()
      message(FATAL_ERROR "Invalid APPX_ARCH_OVERRIDE '${APPX_ARCH_OVERRIDE}' (use x64/x86/arm64/arm)")
    endif()
  elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "AMD64")
    set(APPX_ARCHITECTURE "x64")
  elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "x86")
    set(APPX_ARCHITECTURE "x86")
  elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "ARM64")
    set(APPX_ARCHITECTURE "arm64")
  elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "ARM")
    set(APPX_ARCHITECTURE "arm")
  else()
    message(FATAL_ERROR "Invalid architecture ${CMAKE_SYSTEM_PROCESSOR}")
  endif()

  message(STATUS "Building for ${APPX_ARCHITECTURE}.")

  get_target_property(_output_name ${target} OUTPUT_NAME)
  if(NOT _output_name)
    set(_output_name "${target}")
  endif()

  set(MINGW_UWP_EXECUTABLE "${_output_name}.exe")

  if(NOT MINGW_UWP_PACKAGE_NAME)
    set(MINGW_UWP_PACKAGE_NAME "${_output_name}")
  endif()
  if(NOT MINGW_UWP_DISPLAY_NAME)
    set(MINGW_UWP_DISPLAY_NAME "${MINGW_UWP_PACKAGE_NAME}")
  endif()
  if(NOT MINGW_UWP_PUBLISHER)
    set(MINGW_UWP_PUBLISHER "CN=Unknown")
  endif()

  if(NOT DEFINED MINGW_UWP_NAMESPACE OR "${MINGW_UWP_NAMESPACE}" STREQUAL "")
    set(_namespace "${MINGW_UWP_PACKAGE_NAME}")
    string(REGEX REPLACE "[^0-9A-Za-z_]" "" _namespace "${_namespace}")
    if(_namespace STREQUAL "")
      set(_namespace "App")
    endif()
    string(REGEX MATCH "^[0-9]" _namespace_starts_digit "${_namespace}")
    if(_namespace_starts_digit)
      set(_namespace "_${_namespace}")
    endif()
    set(MINGW_UWP_NAMESPACE "${_namespace}")
  endif()

  if(NOT MINGW_UWP_ENTRYPOINT)
    set(MINGW_UWP_ENTRYPOINT "${MINGW_UWP_NAMESPACE}.App")
  endif()
  if(NOT MINGW_UWP_APP_ID)
    set(MINGW_UWP_APP_ID "App")
  endif()

  if(MSVC)
    target_compile_options(${target} PRIVATE /EHsc)
    target_link_options(${target} PRIVATE /APPCONTAINER)
    target_compile_definitions(${target} PRIVATE UNICODE _UNICODE)
  else()
    if(CMAKE_SYSTEM_PROCESSOR MATCHES "x86|AMD64")
      target_compile_options(${target} PRIVATE -mcx16)
    endif()
    target_link_options(${target} PRIVATE -municode -static)

    set(_prev_required_flags "${CMAKE_REQUIRED_FLAGS}")
    set(CMAKE_REQUIRED_FLAGS "-Wl,--appcontainer")
    check_cxx_source_compiles("int wWinMain(void) {return 0;}" LINKER_SUPPORTS_APPCONTAINER_FLAG)
    set(CMAKE_REQUIRED_FLAGS "${_prev_required_flags}")
    if(LINKER_SUPPORTS_APPCONTAINER_FLAG)
      target_link_options(${target} PRIVATE -Wl,--appcontainer)
    endif()
  endif()

  if(EXISTS "${_MINGW_UWP_ROOT}/Images")
    file(COPY "${_MINGW_UWP_ROOT}/Images" DESTINATION ${CMAKE_BINARY_DIR})
  else()
    message(WARNING "Images directory not found at ${_MINGW_UWP_ROOT}/Images")
  endif()
  if(NOT EXISTS "${_MINGW_UWP_ROOT}/AppxManifest.in")
    message(FATAL_ERROR "AppxManifest.in not found at ${_MINGW_UWP_ROOT}/AppxManifest.in")
  endif()
  configure_file("${_MINGW_UWP_ROOT}/AppxManifest.in" "${CMAKE_BINARY_DIR}/AppxManifest.xml" @ONLY)

  if(EXISTS "${_MINGW_UWP_ROOT}/deps/bin")
    file(GLOB _deps_bins "${_MINGW_UWP_ROOT}/deps/bin/*")
    if(_deps_bins)
      file(COPY ${_deps_bins} DESTINATION ${CMAKE_BINARY_DIR})
    endif()
  endif()

  if(EXISTS "${_MINGW_UWP_ROOT}/deps/include")
    target_include_directories(${target} PRIVATE "${_MINGW_UWP_ROOT}/deps/include")
  endif()

  if(MINGW_UWP_DEPS_LIBS)
    target_link_libraries(${target} PRIVATE ${MINGW_UWP_DEPS_LIBS})
  elseif(MINGW_UWP_USE_DEPS_LIBS AND EXISTS "${_MINGW_UWP_ROOT}/deps/lib")
    file(GLOB _deps_libs "${_MINGW_UWP_ROOT}/deps/lib/*.lib" "${_MINGW_UWP_ROOT}/deps/lib/*.a")
    if(_deps_libs)
      target_link_libraries(${target} PRIVATE ${_deps_libs})
    endif()
  endif()

  if(NOT MSVC)
    if(APPX_ARCHITECTURE STREQUAL "x64")
      target_compile_definitions(${target} PRIVATE _AMD64 _M_AMD64 _WIN64 _M_X64)
    elseif(APPX_ARCHITECTURE STREQUAL "x86")
      target_compile_definitions(${target} PRIVATE _X86 _M_IX86 _WIN32)
    elseif(APPX_ARCHITECTURE STREQUAL "arm64")
      target_compile_definitions(${target} PRIVATE _ARM64)
    elseif(APPX_ARCHITECTURE STREQUAL "arm")
      target_compile_definitions(${target} PRIVATE _ARM)
    endif()
  endif()

  target_compile_definitions(${target} PRIVATE __WINRT__)

  target_link_libraries(${target} PRIVATE windowsapp)

  if(NOT MSVC)
    include(FetchContent)
    set(MINGW_USE_WINRT ON)
    set(MINGW_WINRT_FORCE_FROZEN_SDK ON)
    FetchContent_Declare(MinGWWinRT GIT_REPOSITORY https://github.com/momo-AUX1/cmake-mingw-winrt.git GIT_TAG main)
    FetchContent_MakeAvailable(MinGWWinRT)

    set(_mingw_winrt_hint "")
    if(DEFINED ENV{MINGW_WINRT_DIR})
      set(_mingw_winrt_hint "$ENV{MINGW_WINRT_DIR}")
    endif()
    if(NOT DEFINED MinGWWinRT_SOURCE_DIR OR "${MinGWWinRT_SOURCE_DIR}" STREQUAL "")
      if(NOT "${_mingw_winrt_hint}" STREQUAL "" AND EXISTS "${_mingw_winrt_hint}/MinGWWinRT.cmake")
        set(MinGWWinRT_SOURCE_DIR "${_mingw_winrt_hint}")
      elseif(EXISTS "${CMAKE_BINARY_DIR}/_deps/mingwwinrt-src/MinGWWinRT.cmake")
        set(MinGWWinRT_SOURCE_DIR "${CMAKE_BINARY_DIR}/_deps/mingwwinrt-src")
      endif()
    endif()

    if(DEFINED MinGWWinRT_SOURCE_DIR AND NOT "${MinGWWinRT_SOURCE_DIR}" STREQUAL "")
      include("${MinGWWinRT_SOURCE_DIR}/MinGWWinRT.cmake")
      if(MINGW_WINRT_COROUTINE_ALIAS_FIX AND NOT CMAKE_HOST_WIN32)
        set(_winrt_header "${CMAKE_BINARY_DIR}/_deps/mingwwinrt-src/winrt/include/winrt/Windows.Foundation.h")
        if(EXISTS "${_winrt_header}")
          file(READ "${_winrt_header}" _winrt_contents)
          if(_winrt_contents MATCHES "using coroutine_handle = impl::coroutine_handle<>;"
             AND NOT _winrt_contents MATCHES "using coroutine_handle_t = impl::coroutine_handle<>;")
            string(REPLACE "using coroutine_handle = impl::coroutine_handle<>;"
                           "using coroutine_handle_t = impl::coroutine_handle<>;"
                           _winrt_contents "${_winrt_contents}")
            string(REPLACE "coroutine_handle handle" "coroutine_handle_t handle" _winrt_contents "${_winrt_contents}")
            string(REPLACE "coroutine_handle resume" "coroutine_handle_t resume" _winrt_contents "${_winrt_contents}")
            string(REPLACE "coroutine_handle m_handle" "coroutine_handle_t m_handle" _winrt_contents "${_winrt_contents}")
            file(WRITE "${_winrt_header}" "${_winrt_contents}")
            message(STATUS "Applied WinRT coroutine alias workaround for MinGW GCC.")
          endif()
        endif()
      endif()
    else()
      message(FATAL_ERROR "MinGWWinRT not found. Ensure network access for FetchContent.")
    endif()
  endif()

  set(SIGNING_CERTIFICATE "" CACHE STRING "Path to a .pfx certificate to sign the Appx (optional)")
  set(SIGNING_CERT_PASSWORD "" CACHE STRING "Password for the .pfx certificate (optional)")

  find_program(MAKEAPPX_EXE NAMES makeappx.exe makeappx MakeAppx.exe MakeAppx)
  find_program(SIGNTOOL_EXE NAMES signtool.exe signtool SignTool.exe SignTool)

  if(NOT MAKEAPPX_EXE)
    set(_pf86 "")
    if(NOT "$ENV{ProgramFiles}" STREQUAL "")
      set(_pf_candidate "$ENV{ProgramFiles}")
      if(EXISTS "${_pf_candidate}/Windows Kits/10/bin")
        set(_pf86 "${_pf_candidate}")
      endif()
    endif()
    if(_pf86 STREQUAL "" AND NOT "$ENV{ProgramW6432}" STREQUAL "")
      set(_pf_candidate "$ENV{ProgramW6432}")
      if(EXISTS "${_pf_candidate}/Windows Kits/10/bin")
        set(_pf86 "${_pf_candidate}")
      endif()
    endif()
    if(_pf86 STREQUAL "")
      set(_pf_candidate "C:/Program Files (x86)")
      if(EXISTS "${_pf_candidate}/Windows Kits/10/bin")
        set(_pf86 "${_pf_candidate}")
      endif()
    endif()
    if(NOT _pf86 STREQUAL "")
      set(_win_kits_dir "${_pf86}/Windows Kits/10/bin")
      if(EXISTS "${_win_kits_dir}")
        file(GLOB _versions RELATIVE "${_win_kits_dir}" "${_win_kits_dir}/*")
        foreach(_v ${_versions})
          set(_candidate "${_win_kits_dir}/${_v}/${APPX_ARCHITECTURE}/MakeAppx.exe")
          if(EXISTS "${_candidate}")
            set(MAKEAPPX_EXE "${_candidate}")
            message(STATUS "Found MakeAppx at ${MAKEAPPX_EXE}")
            break()
          endif()
          set(_candidate2 "${_win_kits_dir}/${_v}/x64/MakeAppx.exe")
          if(EXISTS "${_candidate2}")
            set(MAKEAPPX_EXE "${_candidate2}")
            message(STATUS "Found MakeAppx at ${MAKEAPPX_EXE}")
            break()
          endif()
        endforeach()
      endif()
    endif()
  endif()

  if(NOT SIGNTOOL_EXE)
    set(_pf86 "")
    if(NOT "$ENV{ProgramFiles}" STREQUAL "")
      set(_pf_candidate "$ENV{ProgramFiles}")
      if(EXISTS "${_pf_candidate}/Windows Kits/10/bin")
        set(_pf86 "${_pf_candidate}")
      endif()
    endif()
    if(_pf86 STREQUAL "" AND NOT "$ENV{ProgramW6432}" STREQUAL "")
      set(_pf_candidate "$ENV{ProgramW6432}")
      if(EXISTS "${_pf_candidate}/Windows Kits/10/bin")
        set(_pf86 "${_pf_candidate}")
      endif()
    endif()
    if(_pf86 STREQUAL "")
      set(_pf_candidate "C:/Program Files (x86)")
      if(EXISTS "${_pf_candidate}/Windows Kits/10/bin")
        set(_pf86 "${_pf_candidate}")
      endif()
    endif()
    if(NOT _pf86 STREQUAL "")
      set(_win_kits_dir "${_pf86}/Windows Kits/10/bin")
      if(EXISTS "${_win_kits_dir}")
        file(GLOB _versions RELATIVE "${_win_kits_dir}" "${_win_kits_dir}/*")
        foreach(_v ${_versions})
          set(_candidate "${_win_kits_dir}/${_v}/${APPX_ARCHITECTURE}/signtool.exe")
          if(EXISTS "${_candidate}")
            set(SIGNTOOL_EXE "${_candidate}")
            message(STATUS "Found SignTool at ${SIGNTOOL_EXE}")
            break()
          endif()
          set(_candidate2 "${_win_kits_dir}/${_v}/x64/signtool.exe")
          if(EXISTS "${_candidate2}")
            set(SIGNTOOL_EXE "${_candidate2}")
            message(STATUS "Found SignTool at ${SIGNTOOL_EXE}")
            break()
          endif()
        endforeach()
      endif()
    endif()
  endif()

  if(CMAKE_RUNTIME_OUTPUT_DIRECTORY)
    set(_appx_output_dir "${CMAKE_RUNTIME_OUTPUT_DIRECTORY}")
  else()
    set(_appx_output_dir "${CMAKE_CURRENT_BINARY_DIR}")
  endif()

  set(_appx_file "${CMAKE_BINARY_DIR}/${MINGW_UWP_PACKAGE_NAME}.appx")
  set(_msix_file "${CMAKE_BINARY_DIR}/${MINGW_UWP_PACKAGE_NAME}.msix")

  if(MAKEAPPX_EXE)
    if(NOT TARGET appx)
      add_custom_target(appx
        COMMAND ${CMAKE_COMMAND} -E make_directory "${CMAKE_BINARY_DIR}/appx/Images"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different AppxManifest.xml "$<TARGET_FILE:${target}>" "${CMAKE_BINARY_DIR}/appx"
        COMMAND ${CMAKE_COMMAND} -E copy_directory "${_MINGW_UWP_ROOT}/Images" "${CMAKE_BINARY_DIR}/appx/Images"
        COMMAND powershell.exe -NoProfile -Command "& { & '${MAKEAPPX_EXE}' pack /d '${CMAKE_BINARY_DIR}/appx' /p '${_appx_file}' }"
        DEPENDS ${target}
      )
    endif()

    if(SIGNTOOL_EXE)
      if(SIGNING_CERTIFICATE)
        if(SIGNING_CERT_PASSWORD)
          add_custom_command(TARGET appx POST_BUILD
            COMMAND ${SIGNTOOL_EXE} sign /fd SHA256 /a /f "${SIGNING_CERTIFICATE}" /p "${SIGNING_CERT_PASSWORD}" "${_appx_file}"
          )
        else()
          add_custom_command(TARGET appx POST_BUILD
            COMMAND ${SIGNTOOL_EXE} sign /fd SHA256 /a /f "${SIGNING_CERTIFICATE}" "${_appx_file}"
          )
        endif()
      else()
        message(WARNING "SignTool found (${SIGNTOOL_EXE}) but SIGNING_CERTIFICATE not set. Package will not be signed.")
      endif()
    else()
      message(STATUS "MakeAppx found at ${MAKEAPPX_EXE} but SignTool was not found; package will remain unsigned unless you provide SignTool.")
    endif()
  else()
    set(TRY_MAKEAPPX "makeappx.exe")
    if(MAKEAPPX_EXE)
      set(TRY_MAKEAPPX "${MAKEAPPX_EXE}")
    endif()

    if(NOT TARGET appx)
      add_custom_target(appx
        COMMAND ${CMAKE_COMMAND} -E make_directory "${CMAKE_BINARY_DIR}/appx/Images"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different AppxManifest.xml "$<TARGET_FILE:${target}>" "${CMAKE_BINARY_DIR}/appx"
        COMMAND ${CMAKE_COMMAND} -E copy_directory "${_MINGW_UWP_ROOT}/Images" "${CMAKE_BINARY_DIR}/appx/Images"
        COMMAND powershell.exe -NoProfile -Command "& { & '${TRY_MAKEAPPX}' pack /d '${CMAKE_BINARY_DIR}/appx' /p '${_appx_file}' }"
        DEPENDS ${target}
      )
    endif()
  endif()

  if(TARGET appx)
    add_custom_command(TARGET appx POST_BUILD
      COMMAND ${CMAKE_COMMAND} -E copy_if_different "${_appx_file}" "${_appx_output_dir}/${MINGW_UWP_PACKAGE_NAME}.appx"
    )
  endif()

  if(MAKEAPPX_EXE)
    if(NOT TARGET msix)
      add_custom_target(msix
        COMMAND ${CMAKE_COMMAND} -E make_directory "${CMAKE_BINARY_DIR}/msix/Images"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different AppxManifest.xml "$<TARGET_FILE:${target}>" "${CMAKE_BINARY_DIR}/msix"
        COMMAND ${CMAKE_COMMAND} -E copy_directory "${_MINGW_UWP_ROOT}/Images" "${CMAKE_BINARY_DIR}/msix/Images"
        COMMAND powershell.exe -NoProfile -Command "& { & '${MAKEAPPX_EXE}' pack /d '${CMAKE_BINARY_DIR}/msix' /p '${_msix_file}' }"
        DEPENDS ${target}
      )
    endif()

    if(SIGNTOOL_EXE)
      if(SIGNING_CERTIFICATE)
        if(SIGNING_CERT_PASSWORD)
          add_custom_command(TARGET msix POST_BUILD
            COMMAND ${SIGNTOOL_EXE} sign /fd SHA256 /a /f "${SIGNING_CERTIFICATE}" /p "${SIGNING_CERT_PASSWORD}" "${_msix_file}"
          )
        else()
          add_custom_command(TARGET msix POST_BUILD
            COMMAND ${SIGNTOOL_EXE} sign /fd SHA256 /a /f "${SIGNING_CERTIFICATE}" "${_msix_file}"
          )
        endif()
      else()
        message(WARNING "SignTool found (${SIGNTOOL_EXE}) but SIGNING_CERTIFICATE not set. MSIX will not be signed.")
      endif()
    else()
      message(STATUS "MakeAppx found at ${MAKEAPPX_EXE} but SignTool was not found; MSIX will remain unsigned unless you provide SignTool.")
    endif()
  else()
    set(TRY_MAKEAPPX "makeappx.exe")
    if(MAKEAPPX_EXE)
      set(TRY_MAKEAPPX "${MAKEAPPX_EXE}")
    endif()

    if(NOT TARGET msix)
      add_custom_target(msix
        COMMAND ${CMAKE_COMMAND} -E make_directory "${CMAKE_BINARY_DIR}/msix/Images"
        COMMAND ${CMAKE_COMMAND} -E copy_if_different AppxManifest.xml "$<TARGET_FILE:${target}>" "${CMAKE_BINARY_DIR}/msix"
        COMMAND ${CMAKE_COMMAND} -E copy_directory "${_MINGW_UWP_ROOT}/Images" "${CMAKE_BINARY_DIR}/msix/Images"
        COMMAND powershell.exe -NoProfile -Command "& { & '${TRY_MAKEAPPX}' pack /d '${CMAKE_BINARY_DIR}/msix' /p '${_msix_file}' }"
        DEPENDS ${target}
      )
    endif()
  endif()

  if(TARGET msix)
    add_custom_command(TARGET msix POST_BUILD
      COMMAND ${CMAKE_COMMAND} -E copy_if_different "${_msix_file}" "${_appx_output_dir}/${MINGW_UWP_PACKAGE_NAME}.msix"
    )
  endif()
endfunction()

function(mingw_uwp_setup target)
  if(MINGW_UWP_ENABLE)
    _mingw_uwp_setup_impl(${target})
  else()
    message(STATUS "MINGW_UWP_ENABLE=OFF; skipping UWP setup for ${target}.")
  endif()
endfunction()
"""
    module = template.replace("__DEFAULT_PACKAGE_NAME__", default_package).replace("__DEFAULT_PUBLISHER__", default_publisher).replace("__VERSION__",__VERSION__).replace("__GIT_URL__", __GIT_URL__)
    module_path.write_text(module, encoding='utf-8')

def _append_cmake_port_snippet(cmake_path: Path, uwp_dir_name: str, target_name: str, use_deps_libs: bool) -> tuple[bool, str]:
    try:
        content = cmake_path.read_text(encoding='utf-8')
    except Exception as exc:
        return False, f"Failed to read {cmake_path}: {exc}"

    marker = "mingw_uwp_module.cmake"
    if marker in content:
        return False, "CMakeLists.txt already references mingw_uwp_module.cmake."

    lines = [
        "",
        "# --- MinGW UWP Port (generated by mingw-uwp-cli) ---",
        f"set(MINGW_UWP_DIR \"${{CMAKE_CURRENT_LIST_DIR}}/{uwp_dir_name}\")",
        "include(\"${MINGW_UWP_DIR}/mingw_uwp_module.cmake\")",
        "# set(MINGW_UWP_ENABLE ON) # Enable when building UWP",
    ]
    if use_deps_libs:
        lines.append("set(MINGW_UWP_USE_DEPS_LIBS ON)")
    lines.append(f"mingw_uwp_setup({target_name})")
    lines.append("# --- End MinGW UWP Port ---")

    snippet = "\n".join(lines) + "\n"
    if not content.endswith("\n"):
        content += "\n"
    content += snippet
    cmake_path.write_text(content, encoding='utf-8')
    return True, ""

def port_existing_project(project_root: Path, cmake_path: Path, target_name: str, package_name: str, publisher: str, uwp_dir_name: str, arch: str, include_msvc_dlls: bool, use_deps_libs: bool, overwrite: bool, patch_cmake: bool) -> tuple[Path, bool, str]:
    if not project_root.exists() or not project_root.is_dir():
        raise FileNotFoundError(f"Project directory not found: {project_root}")
    if not cmake_path.exists():
        raise FileNotFoundError(f"CMakeLists.txt not found: {cmake_path}")

    uwp_dir_name = uwp_dir_name.strip()
    if not uwp_dir_name:
        raise ValueError("UWP folder name is required.")
    if Path(uwp_dir_name).is_absolute() or len(Path(uwp_dir_name).parts) != 1:
        raise ValueError("UWP folder name must be a simple directory name.")

    uwp_dir = project_root / uwp_dir_name
    if uwp_dir.exists() and any(uwp_dir.iterdir()):
        if overwrite:
            shutil.rmtree(uwp_dir)
        else:
            raise FileExistsError(f"UWP directory already exists and is not empty: {uwp_dir}")

    uwp_dir.mkdir(parents=True, exist_ok=True)
    _copy_default_images(uwp_dir / 'Images')
    _write_port_manifest(uwp_dir / 'AppxManifest.in')
    _write_port_module(uwp_dir / 'mingw_uwp_module.cmake', package_name, publisher or 'CN=Unknown')
    _ensure_deps_layout(uwp_dir)

    if include_msvc_dlls:
        _copy_msvc_dlls(uwp_dir, arch)

    modified = False
    message = ""
    if patch_cmake:
        modified, message = _append_cmake_port_snippet(cmake_path, uwp_dir_name, target_name, use_deps_libs)

    return uwp_dir, modified, message

def _load_config(path: Path) -> dict:
    try:
        data = json.loads(path.read_text(encoding='utf-8'))
    except FileNotFoundError:
        _error(f"❌ Configuration file not found: {path}")
        sys.exit(1)
    except json.JSONDecodeError as exc:
        _error(f"❌ Error parsing config file: {exc}")
        sys.exit(1)
    return data

def _save_config(path: Path, data: dict) -> None:
    path.write_text(json.dumps(data, indent=2), encoding='utf-8')

def _load_config_safe(path: Path) -> Optional[dict]:
    try:
        return json.loads(path.read_text(encoding='utf-8'))
    except Exception:
        return None

def _resolve_project_config_for_dir(project_dir: Path) -> Optional[Path]:
    for candidate in (project_dir, project_dir.parent):
        config_path = candidate / DEFAULT_CONFIG_NAME
        if config_path.exists():
            return config_path
    return None

def _read_device_portal_settings(config_path: Optional[Path]) -> dict:
    if not config_path or not config_path.exists():
        return {}
    data = _load_config_safe(config_path)
    if not isinstance(data, dict):
        return {}
    portal = data.get(DEVICE_PORTAL_KEY, {})
    if isinstance(portal, dict):
        return portal
    return {}

def _save_device_portal_settings(config_path: Optional[Path], settings: dict) -> None:
    if not config_path:
        return
    data = _load_config_safe(config_path) or {}
    data[DEVICE_PORTAL_KEY] = settings
    _save_config(config_path, data)

def _load_device_portal_from_json(json_path: Path) -> dict:
    data = _load_config_safe(json_path)
    if not isinstance(data, dict):
        return {}
    if DEVICE_PORTAL_KEY in data and isinstance(data[DEVICE_PORTAL_KEY], dict):
        portal = data.get(DEVICE_PORTAL_KEY, {})
    else:
        portal = data
    if not isinstance(portal, dict):
        return {}
    return {
        "ip": portal.get("ip", ""),
        "username": portal.get("username", ""),
        "password": portal.get("password", ""),
    }

def _load_tool_db() -> dict:
    if not TOOL_DB_PATH.exists():
        return {}
    try:
        data = json.loads(TOOL_DB_PATH.read_text(encoding='utf-8'))
    except Exception:
        return {}
    return data if isinstance(data, dict) else {}

def _save_tool_db(data: dict) -> None:
    try:
        TOOL_DB_PATH.write_text(json.dumps(data, indent=2), encoding='utf-8')
    except Exception:
        pass

def _remember_tool_path(key: str, value: str) -> None:
    value = value.strip()
    if not value:
        return
    data = _load_tool_db()
    data[key] = value
    _save_tool_db(data)

def _suggest_msix_output(build_dir: Path) -> Path:
    manifest_path = _find_appx_manifest(build_dir)
    base_name = ''
    if manifest_path:
        identity_name, _ = _read_manifest_identity(manifest_path)
        base_name = identity_name or ''
    if not base_name:
        base_name = build_dir.name or 'app'
    safe_name = re.sub(r'[^0-9A-Za-z_.-]', '_', base_name)
    return build_dir / f"{safe_name}.msix"

def _run_makemsix(tool_path: str, build_dir: Path, output_path: Path) -> tuple[bool, str]:
    manifest_path = _find_appx_manifest(build_dir)
    if not manifest_path:
        return False, f"AppxManifest.xml not found in {build_dir}"
    if not output_path:
        return False, "Output MSIX path is required."
    output_path.parent.mkdir(parents=True, exist_ok=True)
    exe = tool_path.strip() or "makemsix"
    command = [exe, "pack", "-d", str(build_dir), "-p", str(output_path)]
    try:
        completed = subprocess.run(command, capture_output=True, text=True)
    except FileNotFoundError:
        return False, f"makemsix not found: {exe}"
    except Exception as exc:
        return False, f"makemsix failed: {exc}"
    output = (completed.stdout or "") + (completed.stderr or "")
    normalized = output.strip()
    if completed.returncode == 0:
        return True, normalized
    if "Unrecognized command: pack" in output or ("Commands:" in output and "pack" not in output):
        hint = (
            "This makemsix build does not support the 'pack' command. "
            "Install a pack-capable build compile with --pack!."
        )
        return False, (normalized + "\n" + hint).strip()
    return False, normalized or f"makemsix failed with exit code {completed.returncode}."

def _install_msix_local(package_path: Path) -> tuple[bool, str]:
    if not WINDOWS:
        return False, "MSIX installation is only available on Windows."
    if not package_path.exists():
        return False, f"Package not found: {package_path}"
    command = f"Add-AppxPackage -Path \"{package_path}\" -ErrorAction Stop"
    code, output = _run_powershell(command)
    if code == 0:
        return True, output.strip()
    return False, output.strip()

def _build_multipart_files(parts: list[tuple[str, Path]]) -> tuple[bytes, str]:
    boundary = f"----codex{uuid.uuid4().hex}"
    body = bytearray()
    for field_name, file_path in parts:
        header = (
            f"--{boundary}\r\n"
            f"Content-Disposition: form-data; name=\"{field_name}\"; filename=\"{file_path.name}\"\r\n"
            "Content-Type: application/octet-stream\r\n\r\n"
        ).encode("utf-8")
        body.extend(header)
        body.extend(file_path.read_bytes())
        body.extend(b"\r\n")
    body.extend(f"--{boundary}--\r\n".encode("utf-8"))
    return bytes(body), boundary

def _multipart_content_length(parts: list[tuple[str, Path]], boundary: str) -> int:
    total = 0
    for field_name, file_path in parts:
        header = (
            f"--{boundary}\r\n"
            f"Content-Disposition: form-data; name=\"{field_name}\"; filename=\"{file_path.name}\"\r\n"
            "Content-Type: application/octet-stream\r\n\r\n"
        ).encode("utf-8")
        total += len(header)
        total += file_path.stat().st_size
        total += len(b"\r\n")
    total += len(f"--{boundary}--\r\n".encode("utf-8"))
    return total

def _send_multipart_stream(conn: http.client.HTTPConnection, parts: list[tuple[str, Path]], boundary: str) -> None:
    for field_name, file_path in parts:
        header = (
            f"--{boundary}\r\n"
            f"Content-Disposition: form-data; name=\"{field_name}\"; filename=\"{file_path.name}\"\r\n"
            "Content-Type: application/octet-stream\r\n\r\n"
        ).encode("utf-8")
        conn.send(header)
        with file_path.open("rb") as handle:
            while True:
                chunk = handle.read(1024 * 1024)
                if not chunk:
                    break
                conn.send(chunk)
        conn.send(b"\r\n")
    conn.send(f"--{boundary}--\r\n".encode("utf-8"))

def _collect_dependencies_for_package(package_path: Path) -> list[Path]:
    deps_dir = package_path.parent / "Dependencies"
    if not deps_dir.exists() or not deps_dir.is_dir():
        return []
    x64_dir = deps_dir / "x64"
    search_root = x64_dir if x64_dir.exists() and x64_dir.is_dir() else deps_dir
    deps = []
    for dep in search_root.glob("*.appx"):
        if dep.is_file():
            deps.append(dep)
    return deps

def _deploy_msix_remote(package_path: Path, host: str, username: str, password: str) -> tuple[bool, str]:
    if not package_path.exists():
        return False, f"Package not found: {package_path}"
    base_url = _normalize_wdp_host(host)
    if not base_url:
        return False, "Device IP/host is required."
    encoded_name = urllib.parse.quote(package_path.name)
    url = f"{base_url}/api/app/packagemanager/package?package={encoded_name}"
    dependencies = _collect_dependencies_for_package(package_path)
    parts = [("package", package_path)]
    for dep in dependencies:
        parts.append(("dependency", dep))
    boundary = f"----codex{uuid.uuid4().hex}"
    content_length = _multipart_content_length(parts, boundary)

    parsed = urllib.parse.urlparse(url)
    context = ssl._create_unverified_context()
    try:
        conn = http.client.HTTPSConnection(
            parsed.hostname,
            parsed.port or 443,
            context=context,
            timeout=240,
        )
        path = parsed.path + (f"?{parsed.query}" if parsed.query else "")
        conn.putrequest("POST", path)
        conn.putheader("Content-Type", f"multipart/form-data; boundary={boundary}")
        conn.putheader("Content-Length", str(content_length))
        if username or password:
            token = base64.b64encode(f"{username}:{password}".encode('utf-8')).decode('ascii')
            conn.putheader("Authorization", f"Basic {token}")
        conn.endheaders()
        _send_multipart_stream(conn, parts, boundary)
        response = conn.getresponse()
        status = response.status
        payload = response.read().decode('utf-8', errors='ignore').strip()
        conn.close()
        if status in (200, 202):
            if dependencies:
                payload = (payload + f"\nIncluded dependencies: {len(dependencies)}").strip()
            return True, payload or "Install request accepted."
        if dependencies:
            payload = (payload + f"\nIncluded dependencies: {len(dependencies)}").strip()
        return False, payload or f"Deploy failed with status {status}."
    except (socket.timeout, TimeoutError) as exc:
        size_mb = content_length / (1024 * 1024)
        return False, f"Upload timed out while sending {size_mb:.1f} MB. The portal may be slow; try wired or smaller packages. ({exc})"
    except OSError as exc:
        if "timed out" in str(exc).lower():
            size_mb = content_length / (1024 * 1024)
            return False, f"Upload timed out while sending {size_mb:.1f} MB. The portal may be slow; try wired or smaller packages. ({exc})"
        return False, f"Deploy failed: {exc}"
    except Exception as exc:
        return False, f"Deploy failed: {exc}"

def _run_osslsigncode(tool_path: str, cert_path: Path, password: str, name: str, input_msix: Path, output_msix: Path) -> tuple[bool, str]:
    if not cert_path.exists():
        return False, f"PFX not found: {cert_path}"
    if not input_msix.exists():
        return False, f"Input MSIX not found: {input_msix}"
    exe = tool_path.strip() or "osslsigncode"
    command = [
        exe, "sign",
        "-pkcs12", str(cert_path),
        "-pass", password,
        "-n", name,
        "-in", str(input_msix),
        "-out", str(output_msix),
    ]
    try:
        completed = subprocess.run(command, capture_output=True, text=True)
    except FileNotFoundError:
        return False, f"osslsigncode not found: {exe}"
    except Exception as exc:
        return False, f"osslsigncode failed: {exc}"
    output = (completed.stdout or "") + (completed.stderr or "")
    if completed.returncode == 0:
        return True, output.strip()
    return False, output.strip() or f"osslsigncode failed with exit code {completed.returncode}."

def _create_pfx_with_openssl(key_path: Path, cert_path: Path, days: int, subject: str, output_path: Path, password: str) -> tuple[bool, str]:
    openssl_path = shutil.which("openssl")
    if not openssl_path:
        return False, "OpenSSL not found. Install OpenSSL and try again."
    if not subject:
        return False, "Certificate subject is required (example: CN=Unknown)."
    if not password:
        return False, "PFX password is required."
    output_path.parent.mkdir(parents=True, exist_ok=True)
    key_path.parent.mkdir(parents=True, exist_ok=True)
    cert_path.parent.mkdir(parents=True, exist_ok=True)
    req_cmd = [
        openssl_path, "req", "-x509", "-newkey", "rsa:2048",
        "-nodes", "-keyout", str(key_path), "-out", str(cert_path),
        "-days", str(days), "-subj", f"/{subject}"
    ]
    req_completed = subprocess.run(req_cmd, capture_output=True, text=True)
    if req_completed.returncode != 0:
        output = (req_completed.stdout or "") + (req_completed.stderr or "")
        return False, output.strip() or "OpenSSL certificate creation failed."
    pfx_cmd = [
        openssl_path, "pkcs12", "-export",
        "-out", str(output_path),
        "-inkey", str(key_path),
        "-in", str(cert_path),
        "-passout", f"pass:{password}",
    ]
    pfx_completed = subprocess.run(pfx_cmd, capture_output=True, text=True)
    output = (pfx_completed.stdout or "") + (pfx_completed.stderr or "")
    if pfx_completed.returncode == 0:
        return True, output.strip() or "PFX created."
    return False, output.strip() or "OpenSSL PFX export failed."

def _create_self_signed_pfx(subject: str, password: str, output_path: Path) -> tuple[bool, str]:
    if not subject:
        return False, "Certificate subject is required (example: CN=MyApp)."
    if not password:
        return False, "PFX password is required."
    if not output_path:
        return False, "PFX output path is required."
    output_path.parent.mkdir(parents=True, exist_ok=True)
    if WINDOWS:
        subject_safe = subject.replace("'", "''")
        password_safe = password.replace("'", "''")
        output_safe = str(output_path).replace("'", "''")
        script = (
            "$pwd = ConvertTo-SecureString '{password}' -AsPlainText -Force;"
            "$cert = New-SelfSignedCertificate -Type CodeSigningCert -Subject '{subject}' "
            "-CertStoreLocation 'Cert:\\CurrentUser\\My';"
            "Export-PfxCertificate -Cert $cert -FilePath '{output}' -Password $pwd | Out-Null;"
            "Remove-Item 'Cert:\\CurrentUser\\My\\$($cert.Thumbprint)' -ErrorAction SilentlyContinue | Out-Null;"
            "Write-Output 'PFX created.'"
        ).format(password=password_safe, subject=subject_safe, output=output_safe)
        code, output = _run_powershell(script)
        if code == 0:
            return True, output.strip()
        return False, output.strip() or "Failed to create PFX."
    openssl_path = shutil.which("openssl")
    if not openssl_path:
        return False, "OpenSSL not found. Install OpenSSL or run on Windows to create a PFX."
    temp_dir = Path(tempfile.mkdtemp())
    key_path = temp_dir / "key.pem"
    cert_path = temp_dir / "cert.pem"
    try:
        req_cmd = [
            openssl_path, "req", "-x509", "-newkey", "rsa:2048",
            "-keyout", str(key_path), "-out", str(cert_path),
            "-days", "365", "-nodes", "-subj", f"/{subject}"
        ]
        req_completed = subprocess.run(req_cmd, capture_output=True, text=True)
        if req_completed.returncode != 0:
            output = (req_completed.stdout or "") + (req_completed.stderr or "")
            return False, output.strip() or "OpenSSL certificate creation failed."
        pfx_cmd = [
            openssl_path, "pkcs12", "-export",
            "-out", str(output_path),
            "-inkey", str(key_path),
            "-in", str(cert_path),
            "-passout", f"pass:{password}",
        ]
        pfx_completed = subprocess.run(pfx_cmd, capture_output=True, text=True)
        output = (pfx_completed.stdout or "") + (pfx_completed.stderr or "")
        if pfx_completed.returncode == 0:
            return True, output.strip() or "PFX created."
        return False, output.strip() or "OpenSSL PFX export failed."
    finally:
        shutil.rmtree(temp_dir, ignore_errors=True)

def _find_appx_manifest(build_dir: Path) -> Optional[Path]:
    for name in ('AppxManifest.xml', 'AppxManifest.appxmanifest'):
        candidate = build_dir / name
        if candidate.exists():
            return candidate
    return None

def _read_manifest_launch_info(manifest_path: Path) -> tuple[str, str, str]:
    try:
        tree = ET.parse(str(manifest_path))
        root = tree.getroot()
        identity = root.find('./{*}Identity')
        identity_name = identity.get('Name') if identity is not None else ''
        app_id = ''
        exe_name = ''
        applications = root.find('./{*}Applications')
        if applications is not None:
            app_el = applications.find('./{*}Application')
            if app_el is not None:
                app_id = app_el.get('Id') or ''
                exe_name = app_el.get('Executable') or ''
        return identity_name or '', app_id or '', exe_name or ''
    except Exception:
        return '', '', ''

def _read_manifest_identity(manifest_path: Path) -> tuple[str, str]:
    identity_name, app_id, _ = _read_manifest_launch_info(manifest_path)
    return identity_name, app_id

def _normalize_exe_name(exe_name: str) -> str:
    if not exe_name:
        return ''
    name = Path(exe_name).name
    if not name:
        return ''
    if not name.lower().endswith('.exe'):
        name += '.exe'
    return name

def _get_process_ids_by_name(exe_name: str) -> list[int]:
    if not WINDOWS:
        return []
    exe = _normalize_exe_name(exe_name)
    if not exe:
        return []
    try:
        completed = subprocess.run(
            ["tasklist", "/FI", f"IMAGENAME eq {exe}", "/FO", "CSV", "/NH"],
            capture_output=True,
            text=True,
        )
    except Exception:
        return []
    if completed.returncode != 0:
        return []
    pids = []
    for line in completed.stdout.splitlines():
        line = line.strip()
        if not line:
            continue
        try:
            row = next(csv.reader([line]))
        except Exception:
            continue
        if len(row) < 2:
            continue
        pid_text = row[1].strip()
        if pid_text.isdigit():
            pids.append(int(pid_text))
    return pids

def _collect_runtime_logs_since(identity_name: str, since_time: datetime, limit: int = 50) -> str:
    if not identity_name:
        return "Package identity not found; cannot filter runtime logs."
    if not WINDOWS:
        return "Runtime log collection is only available on Windows."
    since_iso = since_time.strftime("%Y-%m-%dT%H:%M:%S")
    script = (
        "$pkg = Get-AppxPackage -Name \"{name}\" | Select-Object -First 1;"
        "if (-not $pkg) {{ exit 0 }};"
        "$family = [regex]::Escape($pkg.PackageFamilyName);"
        "$start = [datetime]::Parse(\"{since}\");"
        "try {{"
        "  $events = Get-WinEvent -ErrorAction Stop -FilterHashtable @{{LogName='Microsoft-Windows-AppModel-Runtime/Admin'; StartTime=$start}} "
        "    | Where-Object {{ $_.Message -match $family }} | Sort-Object TimeCreated;"
        "}} catch {{ exit 0 }};"
        "if (-not $events) {{ exit 0 }};"
        "$events | Select-Object -First {limit} | Format-List TimeCreated, Id, LevelDisplayName, Message"
    ).format(name=identity_name.replace('"', '\\"'), since=since_iso, limit=limit)
    _, output = _run_powershell(script)
    return output.strip()

def _tail_runtime_logs(identity_name: str, stop_event: threading.Event, append, poll_seconds: float = 2.0) -> None:
    if not WINDOWS:
        append("Runtime log collection is only available on Windows.")
        return
    if not identity_name:
        append("Package identity not found; skipping runtime log capture.")
        return
    last_time = datetime.now() - timedelta(seconds=1)
    while not stop_event.is_set():
        output = _collect_runtime_logs_since(identity_name, last_time)
        if output:
            append(output)
        last_time = datetime.now()
        stop_event.wait(poll_seconds)

def _stream_debug_output(stop_event: threading.Event, append, pid_set: Optional[set] = None, pid_lock: Optional[threading.Lock] = None) -> None:
    if not WINDOWS:
        append("Debug output capture is only available on Windows.")
        return
    try:
        kernel32 = ctypes.windll.kernel32
    except Exception as exc:
        append(f"Debug output capture unavailable: {exc}")
        return

    kernel32.CreateEventW.restype = ctypes.c_void_p
    kernel32.CreateFileMappingW.restype = ctypes.c_void_p
    kernel32.MapViewOfFile.restype = ctypes.c_void_p
    kernel32.WaitForSingleObject.restype = ctypes.c_uint32
    kernel32.UnmapViewOfFile.argtypes = [ctypes.c_void_p]
    kernel32.UnmapViewOfFile.restype = ctypes.c_bool
    kernel32.CloseHandle.argtypes = [ctypes.c_void_p]
    kernel32.CloseHandle.restype = ctypes.c_bool

    PAGE_READWRITE = 0x04
    FILE_MAP_READ = 0x0004
    WAIT_OBJECT_0 = 0x00000000
    WAIT_TIMEOUT = 0x00000102
    INVALID_HANDLE_VALUE = ctypes.c_void_p(-1).value

    h_buffer_ready = kernel32.CreateEventW(None, False, True, "DBWIN_BUFFER_READY")
    h_data_ready = kernel32.CreateEventW(None, False, False, "DBWIN_DATA_READY")
    h_map = kernel32.CreateFileMappingW(
        ctypes.c_void_p(INVALID_HANDLE_VALUE),
        None,
        PAGE_READWRITE,
        0,
        4096,
        "DBWIN_BUFFER",
    )
    if not h_buffer_ready or not h_data_ready or not h_map:
        append("Debug output capture unavailable (DBWIN objects).")
        return

    p_buf = kernel32.MapViewOfFile(h_map, FILE_MAP_READ, 0, 0, 0)
    if not p_buf:
        kernel32.CloseHandle(h_map)
        kernel32.CloseHandle(h_buffer_ready)
        kernel32.CloseHandle(h_data_ready)
        append("Debug output capture unavailable (DBWIN map failed).")
        return

    try:
        buf = (ctypes.c_byte * 4096).from_address(p_buf)
        while not stop_event.is_set():
            kernel32.SetEvent(h_buffer_ready)
            wait = kernel32.WaitForSingleObject(h_data_ready, 200)
            if wait == WAIT_TIMEOUT:
                continue
            if wait != WAIT_OBJECT_0:
                break
            pid = ctypes.c_uint32.from_buffer(buf).value
            if pid_set is not None and pid_lock is not None:
                with pid_lock:
                    if pid_set and pid not in pid_set:
                        continue
            msg = bytes(buf[4:]).split(b"\x00", 1)[0]
            if not msg:
                continue
            try:
                text = msg.decode("mbcs", errors="replace")
            except Exception:
                text = msg.decode("utf-8", errors="replace")
            append(f"[debug pid {pid}] {text}")
    finally:
        kernel32.UnmapViewOfFile(ctypes.c_void_p(p_buf))
        kernel32.CloseHandle(h_map)
        kernel32.CloseHandle(h_buffer_ready)
        kernel32.CloseHandle(h_data_ready)

def _stream_logs_until_exit(identity_name: str, exe_name: str, append, stop_event: Optional[threading.Event] = None) -> threading.Event:
    active_stop = stop_event or threading.Event()
    exe = _normalize_exe_name(exe_name)
    pid_lock = threading.Lock()
    pid_set: set = set()

    def update_pids() -> list:
        if not exe:
            return []
        pids = _get_process_ids_by_name(exe)
        with pid_lock:
            pid_set.clear()
            pid_set.update(pids)
        return pids

    update_pids()
    threads = []
    if exe:
        debug_thread = threading.Thread(
            target=_stream_debug_output,
            args=(active_stop, append, pid_set, pid_lock),
            daemon=True,
        )
        threads.append(debug_thread)
        debug_thread.start()
    else:
        append("Executable name not found; skipping OutputDebugString capture.")

    runtime_thread = threading.Thread(
        target=_tail_runtime_logs,
        args=(identity_name, active_stop, append),
        daemon=True,
    )
    threads.append(runtime_thread)
    runtime_thread.start()

    seen_running = False
    start_time = time.time()
    while not active_stop.is_set():
        pids = update_pids()
        running = bool(pids)
        if running and not seen_running:
            append("Detected app process PID(s): " + ", ".join(str(pid) for pid in pids))
        if running:
            seen_running = True
        if seen_running and not running:
            break
        if not seen_running and exe and (time.time() - start_time) > 15:
            append("App process was not detected; stopping live log capture.")
            break
        if not exe and (time.time() - start_time) > 60:
            break
        active_stop.wait(0.5)

    active_stop.set()
    for t in threads:
        t.join(timeout=1)
    return active_stop

def _run_powershell(command: str, cwd: Optional[Path] = None) -> tuple[int, str]:
    if not WINDOWS:
        return 1, "PowerShell is only available on Windows."
    completed = subprocess.run(
        ["powershell.exe", "-NoProfile", "-ExecutionPolicy", "Bypass", "-Command", command],
        cwd=str(cwd) if cwd else None,
        capture_output=True,
        text=True,
    )
    output = ""
    if completed.stdout:
        output += completed.stdout
    if completed.stderr:
        output += completed.stderr
    return completed.returncode, output

def _extract_activity_id(text: str) -> Optional[str]:
    match = re.search(r'ActivityId:\s*([0-9a-fA-F-]+)', text)
    if match:
        return match.group(1)
    return None

def _collect_deployment_log(activity_id: str) -> str:
    command = f"Get-AppxLog -ActivityID {activity_id} | Out-String"
    _, output = _run_powershell(command)
    return output.strip()

def _collect_runtime_logs(identity_name: str, minutes: int = 10) -> str:
    if not identity_name:
        return "Package identity not found; cannot filter runtime logs."
    script = (
        "$pkg = Get-AppxPackage -Name \"{name}\" | Select-Object -First 1;"
        "if (-not $pkg) {{ Write-Output \"Package not found for identity.\"; exit 0 }};"
        "$family = [regex]::Escape($pkg.PackageFamilyName);"
        "$events = Get-WinEvent -FilterHashtable @{{LogName='Microsoft-Windows-AppModel-Runtime/Admin'; StartTime=(Get-Date).AddMinutes(-{minutes})}} "
        "| Where-Object {{ $_.Message -match $family }} | Select-Object -First 30;"
        "if (-not $events) {{ Write-Output \"No recent AppModel-Runtime errors found.\"; exit 0 }};"
        "$events | Format-List TimeCreated, Id, LevelDisplayName, Message"
    ).format(name=identity_name.replace('"', '\\"'), minutes=minutes)
    _, output = _run_powershell(script)
    return output.strip()

def _collect_debug_output(identity_name: str, minutes: int = 10) -> str:
    if not WINDOWS:
        return "Debug output collection is only available on Windows."
    if not identity_name:
        return "Package identity not found; cannot filter debug output."
    script = (
        "$pkg = Get-AppxPackage -Name \"{name}\" | Select-Object -First 1;"
        "if (-not $pkg) {{ Write-Output \"Package not found for identity.\"; exit 0 }};"
        "$family = [regex]::Escape($pkg.PackageFamilyName);"
        "$logs = @('Microsoft-Windows-AppModel-Runtime/Debug','Microsoft-Windows-Diagnostics-Logging/Operational');"
        "$events = @();"
        "foreach ($log in $logs) {{"
        "  try {{"
        "    $events += Get-WinEvent -FilterHashtable @{{LogName=$log; StartTime=(Get-Date).AddMinutes(-{minutes})}} "
        "      | Where-Object {{ $_.Message -match $family }};"
        "  }} catch {{ }}"
        "}};"
        "if (-not $events) {{ Write-Output \"No recent debug output found. Ensure debug logs are enabled.\"; exit 0 }};"
        "$events | Select-Object -First 50 | Format-List TimeCreated, Id, Message"
    ).format(name=identity_name.replace('"', '\\"'), minutes=minutes)
    _, output = _run_powershell(script)
    return output.strip()

def _collect_crash_logs(identity_name: str, minutes: int = 60) -> str:
    if not WINDOWS:
        return "Crash log collection is only available on Windows."
    if not identity_name:
        return "Package identity not found; cannot filter crash logs."
    script = (
        "$pkg = Get-AppxPackage -Name \"{name}\" | Select-Object -First 1;"
        "if (-not $pkg) {{ Write-Output \"Package not found for identity.\"; exit 0 }};"
        "$family = [regex]::Escape($pkg.PackageFamilyName);"
        "$events = Get-WinEvent -FilterHashtable @{{LogName='Microsoft-Windows-AppModel-Runtime/Admin'; StartTime=(Get-Date).AddMinutes(-{minutes})}} "
        "| Where-Object {{ ($_.LevelDisplayName -in @('Error','Critical')) -and $_.Message -match $family }} "
        "| Select-Object -First 50;"
        "if (-not $events) {{ Write-Output \"No recent crash events found.\"; exit 0 }};"
        "$events | Format-List TimeCreated, Id, LevelDisplayName, Message"
    ).format(name=identity_name.replace('"', '\\"'), minutes=minutes)
    _, output = _run_powershell(script)
    return output.strip()

def _register_appx(manifest_path: Path) -> tuple[bool, str]:
    command = f"Add-AppxPackage -Register \"{manifest_path}\" -Verbose -ErrorAction Stop"
    code, output = _run_powershell(command, cwd=manifest_path.parent)
    if code == 0:
        return True, output.strip()
    activity_id = _extract_activity_id(output)
    if activity_id:
        log_output = _collect_deployment_log(activity_id)
        if log_output:
            output = output + "\n\n=== Deployment Log ===\n" + log_output
    return False, output.strip()

def _launch_app(identity_name: str, app_id: str) -> tuple[bool, str]:
    if not identity_name or not app_id:
        return False, "Missing package identity or application id in manifest."
    script = (
        "$pkg = Get-AppxPackage -Name \"{name}\" | Select-Object -First 1;"
        "if (-not $pkg) {{ Write-Output \"Package not found after registration.\"; exit 1 }};"
        "$appid = \"{appid}\";"
        "Start-Process \"shell:AppsFolder\\$($pkg.PackageFamilyName)!$appid\""
    ).format(name=identity_name.replace('"', '\\"'), appid=app_id.replace('"', '\\"'))
    code, output = _run_powershell(script)
    if code == 0:
        return True, output.strip()
    return False, output.strip()

def _normalize_wdp_host(host: str) -> str:
    host = host.strip()
    if not host:
        return ''
    if host.startswith('http://') or host.startswith('https://'):
        return host.rstrip('/')
    if ':' in host:
        return f"https://{host}"
    return f"https://{host}:11443"

def _deploy_loose_remote(network_share: str, host: str, username: str, password: str) -> tuple[bool, str]:
    if not network_share:
        return False, "Network share is required for loose deployment."
    base_url = _normalize_wdp_host(host)
    if not base_url:
        return False, "Device IP/host is required."
    url = f"{base_url}/api/app/packagemanager/networkapp"
    payload = {
        "mainpackage": {
            "networkshare": network_share,
            "username": username or "",
            "password": password or "",
        }
    }
    data = json.dumps(payload).encode('utf-8')
    request_obj = urllib.request.Request(url, data=data, method='POST')
    request_obj.add_header('Content-Type', 'application/json')
    if username or password:
        token = base64.b64encode(f"{username}:{password}".encode('utf-8')).decode('ascii')
        request_obj.add_header('Authorization', f'Basic {token}')
    context = ssl._create_unverified_context()
    try:
        with urllib.request.urlopen(request_obj, context=context, timeout=30) as response:
            status = response.getcode()
            body = response.read().decode('utf-8', errors='ignore')
            if status == 200:
                return True, body.strip() or "Deploy request accepted."
            return False, body.strip() or f"Deploy failed with status {status}."
    except urllib.error.HTTPError as exc:
        detail = exc.read().decode('utf-8', errors='ignore') if exc.fp else str(exc)
        return False, f"Deploy failed: {detail or exc}"
    except Exception as exc:
        return False, f"Deploy failed: {exc}"

def _prompt(text: str, current: str) -> str:
    value = input(f"{text} [{current}]: ").strip()
    if value == '-':
        return ''
    return value or current

def _prompt_choice(text: str, current: str, choices) -> str:
    choices_str = "/".join(choices)
    value = input(f"{text} ({choices_str}) [{current}]: ").strip().lower()
    if not value:
        return current
    if value not in choices:
        _warn(f"⚠️  Invalid choice '{value}', keeping '{current}'.")
        return current
    return value

def _prompt_capabilities(current_caps: set) -> set:
    known_caps = sorted(CAPABILITY_DEFS.keys())
    _info("Known capabilities: " + ", ".join(known_caps))
    value = input("Enable capabilities (comma-separated, '-' to clear, blank to keep): ").strip()
    if not value:
        return current_caps
    if value == '-':
        return set()
    requested = {v.strip() for v in value.split(',') if v.strip()}
    enabled = {cap for cap in requested if cap in known_caps}
    unknown = requested - enabled
    if unknown:
        _warn("⚠️  Unknown capabilities ignored: " + ", ".join(sorted(unknown)))
    return enabled

def _resolve_project_dir(config_path: Path, data: dict) -> Path:
    project_dir = data.get('projectDir')
    if project_dir:
        return Path(project_dir).expanduser().resolve()
    return config_path.parent.resolve()

def _update_manifest_publisher(project_dir: Path, publisher: str) -> None:
    for name in ('AppxManifest.in', 'AppxManifest.xml'):
        path = project_dir / name
        if not path.exists():
            continue
        try:
            text = path.read_text(encoding='utf-8')
        except Exception:
            continue
        updated = re.sub(r'Publisher="[^"]*"', f'Publisher="{publisher}"', text)
        if updated != text:
            path.write_text(updated, encoding='utf-8')

def _update_metadata(project_dir: Path, arch: str) -> None:
    path = project_dir / 'metadata.json'
    if not path.exists():
        return
    try:
        data = json.loads(path.read_text(encoding='utf-8'))
    except Exception:
        return
    data['arch'] = arch
    path.write_text(json.dumps(data, indent=2), encoding='utf-8')

def _is_valid_aspect_ratio(w: int, h: int) -> bool:
    if h == 0:
        return False
    ratio = w / h
    return 1.6 <= ratio <= 2.4

def _get_target_size(path: Path, fallback: tuple) -> tuple:
    if Image is None:
        return fallback
    if path.exists():
        try:
            with Image.open(path) as img:
                return img.size
        except Exception:
            return fallback
    return fallback

def _sync_images(project_dir: Path, resources_dir: str, icon_path: str, banner_path: str) -> None:
    if Image is None:
        _warn("⚠️  Pillow not installed; skipping image updates.")
        return

    images_dir = project_dir / 'Images'
    if not images_dir.exists():
        _warn(f"⚠️  Images directory not found at {images_dir}")
        return

    resources_path = Path(resources_dir).expanduser().resolve() if resources_dir else None

    icon_candidates = []
    banner_candidates = []
    if resources_path and resources_path.exists():
        icon_candidates = [
            resources_path / 'icon.png',
            resources_path / 'icon.jpg',
            resources_path / 'icon.jpeg',
            resources_path / 'logo.png',
            resources_path / 'logo.jpg',
            resources_path / 'logo.jpeg',
            resources_path / 'icon-only.png',
            resources_path / 'icon-only.jpg',
        ]
        banner_candidates = [
            resources_path / 'banner.png',
            resources_path / 'banner.jpg',
            resources_path / 'banner.jpeg',
        ]

    if icon_path:
        chosen_icon = Path(icon_path).expanduser().resolve()
    else:
        chosen_icon = next((c for c in icon_candidates if c.exists()), None)

    if banner_path:
        chosen_banner = Path(banner_path).expanduser().resolve()
    else:
        chosen_banner = next((c for c in banner_candidates if c.exists()), None)

    square_targets = {
        'LockScreenLogo.png': (24, 24),
        'Square44x44Logo.png': (44, 44),
        'Square150x150Logo.png': (150, 150),
        'StoreLogo.png': (50, 50),
    }
    banner_targets = {
        'SplashScreen.png': (620, 300),
        'Wide310x150Logo.png': (310, 150),
    }

    if chosen_icon and chosen_icon.exists():
        try:
            with Image.open(chosen_icon) as img:
                w, h = img.size
            if w == h:
                _info(f"🖼  Resizing square icon: {chosen_icon}")
                for name, fallback in square_targets.items():
                    dest = images_dir / name
                    size = _get_target_size(dest, fallback)
                    with Image.open(chosen_icon) as img:
                        resized = img.resize(size, Image.Resampling.LANCZOS)
                        resized.save(dest)
                _success("✅ Icons updated.")
            else:
                _warn("⚠️  Icon is not square; skipping icon updates.")
        except Exception as exc:
            _error(f"❌ Error processing icon: {exc}")
    else:
        _warn("⚠️  No icon found; skipping icon updates.")

    if chosen_banner and chosen_banner.exists():
        try:
            with Image.open(chosen_banner) as img:
                w, h = img.size
            if _is_valid_aspect_ratio(w, h):
                ratio = w / h
                _info(f"🖼  Resizing banner (ratio {ratio:.2f}): {chosen_banner}")
                for name, fallback in banner_targets.items():
                    dest = images_dir / name
                    size = _get_target_size(dest, fallback)
                    with Image.open(chosen_banner) as img:
                        resized = img.resize(size, Image.Resampling.LANCZOS)
                        resized.save(dest)
                _success("✅ Banners updated.")
            else:
                ratio = w / h
                _warn(f"⚠️  Banner ratio {ratio:.2f} is outside 1.6–2.4; skipping banner updates.")
        except Exception as exc:
            _error(f"❌ Error processing banner: {exc}")
    else:
        _warn("⚠️  No banner found; skipping banner updates.")

def edit_project_config(config_path: Path) -> None:
    data = _load_config(config_path)
    project_dir = _resolve_project_dir(config_path, data)
    if not project_dir.exists():
        _warn(f"⚠️  Project directory not found: {project_dir}")

    _info("🛠  Project editor")
    name = data.get('name', project_dir.name)
    arch = data.get('arch', 'x64')
    publisher = data.get('publisher', 'CN=Unknown')
    resources_dir = data.get('resourcesDir', '')
    images = data.get('images', {}) or {}
    icon_path = images.get('icon', '')
    banner_path = images.get('banner', '')
    include_msvc_dlls = bool(data.get('includeMsvcDlls', False))
    manifest_paths = _get_manifest_paths(project_dir)
    current_caps = set()
    if manifest_paths:
        current_caps = _read_manifest_capabilities(manifest_paths[0])

    arch = _prompt_choice("Architecture", arch, ARCH_CHOICES)
    publisher = _prompt("Publisher (CN=...)", publisher)
    resources_dir = _prompt("Resources directory", resources_dir)
    icon_path = _prompt("Icon image path (optional)", icon_path)
    banner_path = _prompt("Banner image path (optional)", banner_path)
    include_msvc = _prompt("Include MSVC DLLs (yes/no)", "yes" if include_msvc_dlls else "no").lower() in ("y", "yes", "true", "1")
    selected_caps = _prompt_capabilities(current_caps)

    data['name'] = name
    data['arch'] = arch
    data['publisher'] = publisher
    data['resourcesDir'] = resources_dir
    data['projectDir'] = str(project_dir)
    data['images'] = {
        'icon': icon_path,
        'banner': banner_path
    }
    data['capabilities'] = sorted(selected_caps)
    data['includeMsvcDlls'] = include_msvc

    _save_config(config_path, data)
    _update_metadata(project_dir, arch)
    _update_manifest_publisher(project_dir, publisher)
    if manifest_paths:
        _update_manifest_capabilities(project_dir, selected_caps)
    _sync_images(project_dir, resources_dir, icon_path, banner_path)
    if include_msvc and project_dir.exists():
        _ensure_deps_layout(project_dir)
        _copy_msvc_dlls(project_dir, arch)
    _success(f"✅ Updated config: {config_path}")

def _apply_vs_style(root):
    from tkinter import ttk

    colors = {
        "bg": "#1e1e1e",
        "panel": "#252526",
        "panel_light": "#2d2d30",
        "panel_dark": "#1b1b1c",
        "border": "#3f3f46",
        "text": "#d4d4d4",
        "muted": "#9e9e9e",
        "accent": "#0e639c",
        "accent_hover": "#1177bb",
    }

    style = ttk.Style(root)
    try:
        style.theme_use("clam")
    except Exception:
        pass

    style.configure("App.TFrame", background=colors["bg"])
    style.configure("TFrame", background=colors["bg"])
    style.configure("Header.TFrame", background=colors["panel"])
    style.configure("Nav.TFrame", background=colors["panel_dark"])
    style.configure("Content.TFrame", background=colors["bg"])
    style.configure("Card.TLabelframe", background=colors["panel"], bordercolor=colors["border"])
    style.configure("Card.TLabelframe.Label", background=colors["panel"], foreground=colors["text"], font=("Segoe UI", 10, "bold"))
    style.configure("TLabelframe", background=colors["panel"], bordercolor=colors["border"])
    style.configure("TLabelframe.Label", background=colors["panel"], foreground=colors["text"])

    style.configure("TLabel", background=colors["bg"], foreground=colors["text"])
    style.configure("Muted.TLabel", background=colors["bg"], foreground=colors["muted"])
    style.configure("Header.TLabel", background=colors["panel"], foreground=colors["text"], font=("Segoe UI", 12, "bold"))

    style.configure("Nav.TButton", background=colors["panel_dark"], foreground=colors["text"], padding=(14, 10), borderwidth=0)
    style.map("Nav.TButton", background=[("active", colors["panel_light"])])
    style.configure("NavActive.TButton", background=colors["accent"], foreground="white", padding=(14, 10), borderwidth=0)
    style.map("NavActive.TButton", background=[("active", colors["accent_hover"])])

    style.configure("Accent.TButton", background=colors["accent"], foreground="white", padding=(12, 8))
    style.map("Accent.TButton", background=[("active", colors["accent_hover"])])
    style.configure("Ghost.TButton", background=colors["panel_light"], foreground=colors["text"], padding=(10, 8))
    style.map("Ghost.TButton", background=[("active", colors["panel"])])

    style.configure("TEntry", fieldbackground=colors["panel_light"], foreground=colors["text"])
    style.configure("TCombobox", fieldbackground=colors["panel_light"], foreground=colors["text"])
    style.map("TCombobox", fieldbackground=[("readonly", colors["panel_light"])])
    style.configure("TCheckbutton", background=colors["bg"], foreground=colors["text"])

    root.configure(bg=colors["bg"])
    return colors

def launch_gui(default_template_dir: Path, default_output_dir: Path, default_arch: str, default_publisher: str, images_dir: Path):
    try:
        import tkinter as tk
        from tkinter import ttk, filedialog, messagebox
    except Exception as exc:
        print(f"Failed to start GUI: {exc}")
        sys.exit(1)

    root = tk.Tk()
    root.title("MinGW UWP Studio")
    root.geometry("980x640")
    root.minsize(900, 560)
    root.resizable(True, True)

    colors = _apply_vs_style(root)
    tool_db = _load_tool_db()

    main = ttk.Frame(root, style="App.TFrame")
    main.pack(fill=tk.BOTH, expand=True)
    main.columnconfigure(1, weight=1)
    main.rowconfigure(1, weight=1)

    header = ttk.Frame(main, style="Header.TFrame", padding=(16, 10))
    header.grid(row=0, column=0, columnspan=2, sticky="ew")
    header.columnconfigure(1, weight=1)

    title = ttk.Label(header, text="MinGW UWP Studio", style="Header.TLabel")
    title.grid(row=0, column=0, sticky="w")
    header.columnconfigure(1, weight=0)

    nav = ttk.Frame(main, style="Nav.TFrame", padding=(8, 12))
    nav.grid(row=1, column=0, sticky="ns")
    nav.columnconfigure(0, weight=1)

    content_container = ttk.Frame(main, style="Content.TFrame")
    content_container.grid(row=1, column=1, sticky="nsew")
    content_container.columnconfigure(0, weight=1)
    content_container.rowconfigure(0, weight=1)

    content_canvas = tk.Canvas(content_container, background=colors["bg"], highlightthickness=0)
    content_scroll = ttk.Scrollbar(content_container, orient=tk.VERTICAL, command=content_canvas.yview)
    content_canvas.configure(yscrollcommand=content_scroll.set)
    content_canvas.grid(row=0, column=0, sticky="nsew")
    content_scroll.grid(row=0, column=1, sticky="ns")

    content = ttk.Frame(content_canvas, style="Content.TFrame", padding=(16, 16))
    content_id = content_canvas.create_window((0, 0), window=content, anchor="nw")
    content.columnconfigure(0, weight=1)

    def _on_content_configure(event):
        content_canvas.configure(scrollregion=content_canvas.bbox("all"))

    def _on_canvas_configure(event):
        content_canvas.itemconfigure(content_id, width=event.width)

    content.bind("<Configure>", _on_content_configure)
    content_canvas.bind("<Configure>", _on_canvas_configure)

    def _on_mousewheel(event):
        if event.delta:
            content_canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
        elif event.num == 4:
            content_canvas.yview_scroll(-3, "units")
        elif event.num == 5:
            content_canvas.yview_scroll(3, "units")

    def _bind_mousewheel(_):
        content_canvas.bind_all("<MouseWheel>", _on_mousewheel)
        content_canvas.bind_all("<Button-4>", _on_mousewheel)
        content_canvas.bind_all("<Button-5>", _on_mousewheel)

    def _unbind_mousewheel(_):
        content_canvas.unbind_all("<MouseWheel>")
        content_canvas.unbind_all("<Button-4>")
        content_canvas.unbind_all("<Button-5>")

    content_canvas.bind("<Enter>", _bind_mousewheel)
    content_canvas.bind("<Leave>", _unbind_mousewheel)

    pages = {}
    nav_buttons = {}

    def show_page(name: str):
        for page in pages.values():
            page.grid_remove()
        pages[name].grid(row=0, column=0, sticky="nsew")
        for key, button in nav_buttons.items():
            button.configure(style="NavActive.TButton" if key == name else "Nav.TButton")
        content_canvas.yview_moveto(0)

    def add_nav_button(name: str, text: str):
        button = ttk.Button(nav, text=text, style="Nav.TButton", command=lambda: show_page(name))
        button.grid(sticky="ew", pady=4)
        nav_buttons[name] = button

    def create_card(parent, title_text):
        frame = ttk.Labelframe(parent, text=title_text, style="Card.TLabelframe", padding=12)
        frame.columnconfigure(1, weight=1)
        return frame

    # Create Project Page
    create_page = ttk.Frame(content, style="Content.TFrame")
    create_page.columnconfigure(0, weight=1)
    create_page.rowconfigure(2, weight=1)

    create_header_row = ttk.Frame(create_page, style="Content.TFrame")
    create_header_row.grid(row=0, column=0, sticky="ew")
    create_header_row.columnconfigure(0, weight=1)
    create_header_row.columnconfigure(1, weight=0)
    create_header = ttk.Label(create_header_row, text="New Project", style="Header.TLabel")
    create_header.grid(row=0, column=0, sticky="w")
    create_subtitle = ttk.Label(create_header_row, text="Create a new project or port an existing CMake build.", style="Muted.TLabel")
    create_subtitle.grid(row=0, column=1, sticky="e")

    mode_frame = ttk.Frame(create_page, style="Content.TFrame")
    mode_frame.grid(row=1, column=0, sticky="ew", pady=(10, 0))
    mode_create_btn = ttk.Button(mode_frame, text="Create", style="Accent.TButton", command=lambda: set_create_mode("create"))
    mode_port_btn = ttk.Button(mode_frame, text="Port", style="Ghost.TButton", command=lambda: set_create_mode("port"))
    mode_create_btn.grid(row=0, column=0, sticky="w")
    mode_port_btn.grid(row=0, column=1, sticky="w", padx=(8, 0))

    create_form_frame = ttk.Frame(create_page, style="Content.TFrame")
    create_form_frame.grid(row=2, column=0, sticky="nsew", pady=(12, 0))
    create_form_frame.columnconfigure(0, weight=1)

    settings_card = create_card(create_form_frame, "Project settings")
    settings_card.grid(row=0, column=0, sticky="ew", pady=(0, 12))

    paths_card = create_card(create_form_frame, "Paths")
    paths_card.grid(row=1, column=0, sticky="ew", pady=(0, 12))

    options_card = create_card(create_form_frame, "Options")
    options_card.grid(row=2, column=0, sticky="ew")

    project_type_var = tk.StringVar(value="xaml")
    project_type = ttk.Combobox(settings_card, textvariable=project_type_var, state="readonly")
    project_type["values"] = ("library", "console", "xaml", "corewindow")

    name_var = tk.StringVar(value="MyApp")
    name_entry = ttk.Entry(settings_card, textvariable=name_var)

    arch_var = tk.StringVar(value=default_arch)
    arch_combo = ttk.Combobox(settings_card, textvariable=arch_var, state="readonly")
    arch_combo["values"] = ("x64", "x86", "arm64", "arm")

    publisher_var = tk.StringVar(value=default_publisher)
    publisher_entry = ttk.Entry(settings_card, textvariable=publisher_var)

    def add_row(parent, row, label_text, widget, button=None):
        label = ttk.Label(parent, text=label_text)
        label.grid(row=row, column=0, sticky="w", pady=6)
        widget.grid(row=row, column=1, sticky="ew", padx=(10, 0), pady=6)
        if button is not None:
            button.grid(row=row, column=2, sticky="e", padx=(8, 0), pady=6)

    add_row(settings_card, 0, "Project type", project_type)
    add_row(settings_card, 1, "Project name", name_entry)
    add_row(settings_card, 2, "Architecture", arch_combo)
    add_row(settings_card, 3, "Publisher", publisher_entry)

    output_var = tk.StringVar(value=str(default_output_dir))
    output_entry = ttk.Entry(paths_card, textvariable=output_var)
    output_button = ttk.Button(paths_card, text="Browse", style="Ghost.TButton", command=lambda: output_var.set(filedialog.askdirectory() or output_var.get()))

    template_var = tk.StringVar(value=str(default_template_dir))
    template_entry = ttk.Entry(paths_card, textvariable=template_var)
    template_button = ttk.Button(paths_card, text="Browse", style="Ghost.TButton", command=lambda: template_var.set(filedialog.askdirectory() or template_var.get()))

    add_row(paths_card, 0, "Output directory", output_entry, output_button)
    add_row(paths_card, 1, "Template directory", template_entry, template_button)

    overwrite_var = tk.BooleanVar(value=False)
    include_msvc_var = tk.BooleanVar(value=False)
    ttk.Checkbutton(options_card, text="Overwrite output directory if it exists", variable=overwrite_var).grid(row=0, column=0, sticky="w", pady=4)
    ttk.Checkbutton(options_card, text="Include MSVC DLLs in deps/bin", variable=include_msvc_var).grid(row=1, column=0, sticky="w", pady=4)

    create_status = tk.StringVar(value="")
    status_label = ttk.Label(create_form_frame, textvariable=create_status, style="Muted.TLabel")
    status_label.grid(row=3, column=0, sticky="w", pady=(10, 0))

    def on_create():
        project_name = name_var.get().strip()
        if not project_name:
            messagebox.showerror("Missing name", "Project name is required.")
            return

        out_dir = Path(output_var.get()).expanduser().resolve() / project_name
        template_dir = Path(template_var.get()).expanduser().resolve()

        try:
            generate_project(
                template_dir=template_dir,
                project_type=project_type_var.get(),
                project_name=project_name,
                out_dir=out_dir,
                arch=arch_var.get(),
                publisher=publisher_var.get().strip() or default_publisher,
                reuse_images=images_dir,
                overwrite=overwrite_var.get(),
                include_msvc_dlls=include_msvc_var.get(),
            )
        except Exception as exc:
            messagebox.showerror("Generation failed", str(exc))
            create_status.set(f"Failed: {exc}")
            return

        messagebox.showinfo("Project created", f"Project created at:\n{out_dir}")
        create_status.set(f"Project created at {out_dir}")

    create_actions = ttk.Frame(create_page, style="Content.TFrame")
    create_actions.grid(row=3, column=0, sticky="e", pady=(12, 0))
    ttk.Button(create_actions, text="Create Project", style="Accent.TButton", command=on_create).grid(row=0, column=0, padx=(0, 8))
    ttk.Button(create_actions, text="Close", style="Ghost.TButton", command=root.destroy).grid(row=0, column=1)

    # Port Existing Project
    port_form_frame = ttk.Frame(create_page, style="Content.TFrame")
    port_form_frame.grid(row=2, column=0, sticky="nsew", pady=(12, 0))
    port_form_frame.columnconfigure(0, weight=1)

    port_settings_card = create_card(port_form_frame, "Port settings")
    port_settings_card.grid(row=0, column=0, sticky="ew", pady=(0, 12))

    port_paths_card = create_card(port_form_frame, "Paths")
    port_paths_card.grid(row=1, column=0, sticky="ew", pady=(0, 12))

    port_options_card = create_card(port_form_frame, "Options")
    port_options_card.grid(row=2, column=0, sticky="ew")

    port_root_var = tk.StringVar(value="")
    port_root_entry = ttk.Entry(port_paths_card, textvariable=port_root_var)
    port_root_button = ttk.Button(port_paths_card, text="Browse", style="Ghost.TButton")

    port_cmake_var = tk.StringVar(value="")
    port_cmake_entry = ttk.Entry(port_paths_card, textvariable=port_cmake_var)
    port_cmake_button = ttk.Button(port_paths_card, text="Browse", style="Ghost.TButton")

    port_target_var = tk.StringVar(value="")
    port_target_entry = ttk.Entry(port_settings_card, textvariable=port_target_var)

    port_package_var = tk.StringVar(value="")
    port_package_entry = ttk.Entry(port_settings_card, textvariable=port_package_var)

    port_publisher_var = tk.StringVar(value=default_publisher)
    port_publisher_entry = ttk.Entry(port_settings_card, textvariable=port_publisher_var)

    port_uwp_dir_var = tk.StringVar(value="uwp")
    port_uwp_dir_entry = ttk.Entry(port_settings_card, textvariable=port_uwp_dir_var)

    add_row(port_settings_card, 0, "Target name", port_target_entry)
    add_row(port_settings_card, 1, "Package name", port_package_entry)
    add_row(port_settings_card, 2, "Publisher", port_publisher_entry)
    add_row(port_settings_card, 3, "UWP folder name", port_uwp_dir_entry)

    add_row(port_paths_card, 0, "Project root", port_root_entry, port_root_button)
    add_row(port_paths_card, 1, "Root CMakeLists.txt", port_cmake_entry, port_cmake_button)

    port_overwrite_var = tk.BooleanVar(value=False)
    port_include_msvc_var = tk.BooleanVar(value=False)
    port_use_deps_libs_var = tk.BooleanVar(value=False)
    port_patch_cmake_var = tk.BooleanVar(value=True)
    ttk.Checkbutton(port_options_card, text="Overwrite UWP folder if it exists", variable=port_overwrite_var).grid(row=0, column=0, sticky="w", pady=4)
    ttk.Checkbutton(port_options_card, text="Include MSVC DLLs in deps/bin", variable=port_include_msvc_var).grid(row=1, column=0, sticky="w", pady=4)
    ttk.Checkbutton(port_options_card, text="Auto-link libs in deps/lib", variable=port_use_deps_libs_var).grid(row=2, column=0, sticky="w", pady=4)
    ttk.Checkbutton(port_options_card, text="Update CMakeLists.txt with module include", variable=port_patch_cmake_var).grid(row=3, column=0, sticky="w", pady=4)
    ttk.Label(port_options_card, text="UWP folder will include Images/, AppxManifest.in, deps/, and mingw_uwp_module.cmake.", style="Muted.TLabel").grid(row=4, column=0, sticky="w", pady=(6, 0))

    port_status = tk.StringVar(value="")
    port_status_label = ttk.Label(port_form_frame, textvariable=port_status, style="Muted.TLabel")
    port_status_label.grid(row=3, column=0, sticky="w", pady=(10, 0))

    def apply_port_defaults(cmake_file: Path):
        project_name, target_name = _infer_cmake_defaults(cmake_file)
        if project_name and not port_package_var.get().strip():
            port_package_var.set(project_name)
        if target_name and not port_target_var.get().strip():
            port_target_var.set(target_name)
        if not port_package_var.get().strip() and port_root_var.get():
            port_package_var.set(Path(port_root_var.get()).name)

    def browse_port_root():
        path = filedialog.askdirectory()
        if not path:
            return
        port_root_var.set(path)
        cmake_candidate = Path(path) / "CMakeLists.txt"
        if cmake_candidate.exists():
            port_cmake_var.set(str(cmake_candidate))
            apply_port_defaults(cmake_candidate)

    def browse_port_cmake():
        path = filedialog.askopenfilename(filetypes=[("CMakeLists", "CMakeLists.txt"), ("All files", "*")])
        if not path:
            return
        port_cmake_var.set(path)
        port_root_var.set(str(Path(path).parent))
        apply_port_defaults(Path(path))

    port_root_button.configure(command=browse_port_root)
    port_cmake_button.configure(command=browse_port_cmake)

    port_actions = ttk.Frame(create_page, style="Content.TFrame")
    port_actions.grid(row=3, column=0, sticky="e", pady=(12, 0))

    def on_port():
        project_root_text = port_root_var.get().strip()
        cmake_text = port_cmake_var.get().strip()
        target_name = port_target_var.get().strip()
        package_name = port_package_var.get().strip()
        publisher = port_publisher_var.get().strip() or default_publisher
        uwp_dir_name = port_uwp_dir_var.get().strip()

        if not project_root_text:
            messagebox.showerror("Missing project", "Project root is required.")
            return
        if not cmake_text:
            messagebox.showerror("Missing CMakeLists", "Root CMakeLists.txt is required.")
            return
        if not target_name:
            messagebox.showerror("Missing target", "Target name is required.")
            return
        if not package_name:
            package_name = target_name

        project_root = Path(project_root_text).expanduser().resolve()
        cmake_path = Path(cmake_text).expanduser().resolve()

        try:
            uwp_dir, modified, note = port_existing_project(
                project_root=project_root,
                cmake_path=cmake_path,
                target_name=target_name,
                package_name=package_name,
                publisher=publisher,
                uwp_dir_name=uwp_dir_name,
                arch=default_arch,
                include_msvc_dlls=port_include_msvc_var.get(),
                use_deps_libs=port_use_deps_libs_var.get(),
                overwrite=port_overwrite_var.get(),
                patch_cmake=port_patch_cmake_var.get(),
            )
        except Exception as exc:
            messagebox.showerror("Port failed", str(exc))
            port_status.set(f"Failed: {exc}")
            return

        details = f"UWP files created at:\n{uwp_dir}"
        if modified:
            details += "\nCMakeLists.txt updated."
        elif note:
            details += f"\n{note}"
        messagebox.showinfo("Port complete", details)
        port_status.set(f"Ported at {uwp_dir}")

    ttk.Button(port_actions, text="Port Project", style="Accent.TButton", command=on_port).grid(row=0, column=0, padx=(0, 8))
    ttk.Button(port_actions, text="Close", style="Ghost.TButton", command=root.destroy).grid(row=0, column=1)

    def set_create_mode(mode: str):
        if mode == "port":
            create_form_frame.grid_remove()
            create_actions.grid_remove()
            port_form_frame.grid()
            port_actions.grid()
            mode_create_btn.configure(style="Ghost.TButton")
            mode_port_btn.configure(style="Accent.TButton")
        else:
            port_form_frame.grid_remove()
            port_actions.grid_remove()
            create_form_frame.grid()
            create_actions.grid()
            mode_create_btn.configure(style="Accent.TButton")
            mode_port_btn.configure(style="Ghost.TButton")

    set_create_mode("create")

    pages["create"] = create_page

    # Editor Page
    editor_page = ttk.Frame(content, style="Content.TFrame")
    editor_page.columnconfigure(0, weight=1)
    editor_page.rowconfigure(1, weight=1)

    editor_header_row = ttk.Frame(editor_page, style="Content.TFrame")
    editor_header_row.grid(row=0, column=0, sticky="ew")
    editor_header_row.columnconfigure(0, weight=1)
    editor_header_row.columnconfigure(1, weight=0)
    editor_header = ttk.Label(editor_header_row, text="Edit project configuration", style="Header.TLabel")
    editor_header.grid(row=0, column=0, sticky="w")
    editor_hint = ttk.Label(editor_header_row, text="Open mingw_winrt.json to update capabilities, assets, and metadata.", style="Muted.TLabel")
    editor_hint.grid(row=0, column=1, sticky="e")

    editor_card = create_card(editor_page, "Project config")
    editor_card.grid(row=1, column=0, sticky="ew", pady=(12, 0))

    editor_path_var = tk.StringVar(value="")
    editor_entry = ttk.Entry(editor_card, textvariable=editor_path_var)

    def browse_config():
        path = filedialog.askopenfilename()
        if path:
            editor_path_var.set(path)

    def open_editor():
        path = editor_path_var.get().strip()
        if not path:
            messagebox.showerror("Missing config", "Select a mingw_winrt.json file first.")
            return
        config_path = Path(path)
        if not config_path.exists():
            messagebox.showerror("Missing config", f"Config not found: {config_path}")
            return
        edit_project_config_gui(config_path, parent=root)

    add_row(editor_card, 0, "Config file", editor_entry, ttk.Button(editor_card, text="Browse", style="Ghost.TButton", command=browse_config))
    ttk.Button(editor_page, text="Open Editor", style="Accent.TButton", command=open_editor).grid(row=2, column=0, sticky="e", pady=(12, 0))

    pages["editor"] = editor_page

    # Runner / Installer Page
    runner_page = ttk.Frame(content, style="Content.TFrame")
    runner_page.columnconfigure(0, weight=1)
    runner_page.rowconfigure(4, weight=1)

    runner_header_row = ttk.Frame(runner_page, style="Content.TFrame")
    runner_header_row.grid(row=0, column=0, sticky="ew")
    runner_header_row.columnconfigure(0, weight=1)
    runner_header_row.columnconfigure(1, weight=0)
    runner_header = ttk.Label(runner_header_row, text="Register / Install loose apps", style="Header.TLabel")
    runner_header.grid(row=0, column=0, sticky="w")
    runner_hint = ttk.Label(runner_header_row, text="Register loose builds, install MSIX packages, or deploy via device portal.", style="Muted.TLabel")
    runner_hint.grid(row=0, column=1, sticky="e")

    settings_card = create_card(runner_page, "Device portal settings")
    settings_card.grid(row=1, column=0, sticky="ew", pady=(12, 8))

    local_card = create_card(runner_page, "Loose folder (local + remote)")
    local_card.grid(row=2, column=0, sticky="ew", pady=(0, 12))

    msix_card = create_card(runner_page, "MSIX install / deploy")
    msix_card.grid(row=3, column=0, sticky="ew", pady=(0, 12))

    log_card = create_card(runner_page, "Output")
    log_card.grid(row=4, column=0, sticky="nsew")
    log_card.columnconfigure(0, weight=1)
    log_card.rowconfigure(0, weight=1)

    build_dir_var = tk.StringVar(value=str(Path.cwd()))
    build_dir_entry = ttk.Entry(local_card, textvariable=build_dir_var)

    manifest_status = tk.StringVar(value="Select a build folder that contains AppxManifest.xml.")
    manifest_label = ttk.Label(local_card, textvariable=manifest_status, style="Muted.TLabel")

    def append_log(message: str):
        log_text.configure(state="normal")
        log_text.insert(tk.END, message.rstrip() + "\n")
        log_text.see(tk.END)
        log_text.configure(state="disabled")

    def append_log_async(message: str):
        root.after(0, lambda: append_log(message))

    def run_async(task, done_label: Optional[str] = None):
        def _runner():
            try:
                task()
            finally:
                if done_label:
                    append_log_async(done_label)
        threading.Thread(target=_runner, daemon=True).start()

    current_manifest = {"path": None, "identity": "", "app_id": "", "exe": "", "config": None}
    settings_config_state = {"path": None}
    settings_config_var = tk.StringVar(value="")

    def set_settings_config(path: Optional[Path]):
        settings_config_state["path"] = path
        settings_config_var.set(str(path.parent) if path else "")
        if not path:
            ip_var.set("")
            username_var.set("")
            password_var.set("")
            return
        portal = _read_device_portal_settings(path)
        ip_var.set(portal.get("ip", ""))
        username_var.set(portal.get("username", ""))
        password_var.set(portal.get("password", ""))

    def update_manifest_state(path: Optional[Path]):
        current_manifest["path"] = None
        current_manifest["identity"] = ""
        current_manifest["app_id"] = ""
        current_manifest["exe"] = ""
        current_manifest["config"] = None
        if not path:
            manifest_status.set("Select a build folder that contains AppxManifest.xml.")
            return
        manifest_path = _find_appx_manifest(path)
        if not manifest_path:
            manifest_status.set("No AppxManifest.xml found in this folder.")
            return
        identity_name, app_id, exe_name = _read_manifest_launch_info(manifest_path)
        current_manifest["path"] = manifest_path
        current_manifest["identity"] = identity_name
        current_manifest["app_id"] = app_id
        current_manifest["exe"] = exe_name
        config_path = _resolve_project_config_for_dir(path)
        current_manifest["config"] = config_path
        manifest_status.set(f"Manifest OK: {manifest_path.name}")
        set_settings_config(config_path)

    def browse_build_dir():
        path = filedialog.askdirectory()
        if path:
            build_dir_var.set(path)
            update_manifest_state(Path(path))

    def register_loose():
        if not current_manifest["path"]:
            messagebox.showerror("Missing manifest", "Select a build folder with AppxManifest.xml first.")
            return
        manifest_path = current_manifest["path"]
        append_log("== Registering appx (loose) ==")

        def _task():
            ok, output = _register_appx(manifest_path)
            if output:
                append_log_async(output)
            if not ok:
                append_log_async("Registration failed.")
                return
            append_log_async("Registration completed.")

        run_async(_task)

    add_row(local_card, 0, "Build folder", build_dir_entry, ttk.Button(local_card, text="Browse", style="Ghost.TButton", command=browse_build_dir))
    manifest_label.grid(row=1, column=0, columnspan=3, sticky="w", pady=(0, 8))
    def deploy_loose():
        share_path = build_dir_var.get().strip()
        if not share_path:
            messagebox.showerror("Missing folder", "Select a build folder first.")
            return
        if not (share_path.startswith("\\\\") or share_path.startswith("//")):
            messagebox.showerror("Missing network share", "Remote deploy requires a UNC path (e.g. \\\\host\\share\\path).")
            return
        if not save_portal_settings():
            return
        append_log("== Deploying loose folder to device portal ==")

        def _task():
            ok, output = _deploy_loose_remote(
                share_path,
                ip_var.get().strip(),
                username_var.get().strip(),
                password_var.get().strip(),
            )
            if output:
                append_log_async(output)
            append_log_async("Remote deploy accepted." if ok else "Remote deploy failed.")

        run_async(_task)

    local_actions = ttk.Frame(local_card, style="Content.TFrame")
    local_actions.grid(row=2, column=0, columnspan=3, sticky="e", pady=(0, 6))
    ttk.Button(local_actions, text="Register", style="Accent.TButton", command=register_loose).grid(row=0, column=0, padx=(0, 8))
    ttk.Button(local_actions, text="Deploy to Device", style="Ghost.TButton", command=deploy_loose).grid(row=0, column=1, padx=(0, 8))
    ttk.Button(local_actions, text="Get WinDbg", style="Ghost.TButton", command=lambda: webbrowser.open("https://aka.ms/windbg/download")).grid(row=0, column=2)

    msix_path_var = tk.StringVar(value="")
    msix_status = tk.StringVar(value="Select a .msix/.appx package to install or deploy.")

    def update_msix_status(path: Optional[Path]):
        if not path:
            msix_status.set("Select a .msix/.appx package to install or deploy.")
            return
        if not path.exists():
            msix_status.set("Package not found.")
            return
        msix_status.set(f"Package OK: {path.name}")

    def browse_msix():
        path = filedialog.askopenfilename(filetypes=[("MSIX/AppX packages", "*.msix *.msixbundle *.appx *.appxbundle"), ("All files", "*.*")])
        if path:
            msix_path_var.set(path)
            update_msix_status(Path(path))

    def install_msix():
        path_text = msix_path_var.get().strip()
        if not path_text:
            messagebox.showerror("Missing package", "Select a package file first.")
            return
        package_path = Path(path_text).expanduser().resolve()
        append_log("== Installing MSIX locally ==")
        ok, output = _install_msix_local(package_path)
        if output:
            append_log(output)
        if ok:
            append_log("MSIX install started.")
        else:
            append_log("MSIX install failed.")

    def deploy_msix():
        path_text = msix_path_var.get().strip()
        if not path_text:
            messagebox.showerror("Missing package", "Select a package file first.")
            return
        if not save_portal_settings():
            return
        package_path = Path(path_text).expanduser().resolve()
        append_log("== Deploying MSIX to device portal ==")

        def _task():
            ok, output = _deploy_msix_remote(
                package_path,
                ip_var.get().strip(),
                username_var.get().strip(),
                password_var.get().strip(),
            )
            if output:
                append_log_async(output)
            append_log_async("Remote install accepted." if ok else "Remote install failed.")

        run_async(_task)

    add_row(msix_card, 0, "Package file", ttk.Entry(msix_card, textvariable=msix_path_var), ttk.Button(msix_card, text="Browse", style="Ghost.TButton", command=browse_msix))
    ttk.Label(msix_card, textvariable=msix_status, style="Muted.TLabel").grid(row=1, column=0, columnspan=3, sticky="w", pady=(0, 8))
    msix_actions = ttk.Frame(msix_card, style="Content.TFrame")
    msix_actions.grid(row=2, column=0, columnspan=3, sticky="e", pady=(0, 6))
    ttk.Button(msix_actions, text="Install locally", style="Accent.TButton", command=install_msix).grid(row=0, column=0, padx=(0, 8))
    ttk.Button(msix_actions, text="Deploy to device", style="Ghost.TButton", command=deploy_msix).grid(row=0, column=1)

    ip_var = tk.StringVar(value="")
    username_var = tk.StringVar(value="")
    password_var = tk.StringVar(value="")

    update_manifest_state(Path(build_dir_var.get()))

    def load_settings_config():
        selected = settings_config_var.get().strip()
        if not selected:
            selected = filedialog.askdirectory()
        if not selected:
            return
        candidate = Path(selected).expanduser().resolve()
        if candidate.is_file() and candidate.name == DEFAULT_CONFIG_NAME:
            config_path = candidate
        else:
            config_path = candidate / DEFAULT_CONFIG_NAME
        if not config_path.exists():
            messagebox.showerror("Config not found", f"Missing {DEFAULT_CONFIG_NAME} in {candidate}")
            return
        set_settings_config(config_path)

    add_row(settings_card, 0, "Project folder", ttk.Entry(settings_card, textvariable=settings_config_var), ttk.Button(settings_card, text="Load", style="Ghost.TButton", command=load_settings_config))
    add_row(settings_card, 1, "Device IP / host", ttk.Entry(settings_card, textvariable=ip_var))
    add_row(settings_card, 2, "Username", ttk.Entry(settings_card, textvariable=username_var))
    add_row(settings_card, 3, "Password", ttk.Entry(settings_card, textvariable=password_var, show="*"))

    def save_portal_settings():
        if not settings_config_state["path"]:
            messagebox.showerror("Missing config", "Load a project folder with mingw_winrt.json first.")
            return False
        settings = {
            "ip": ip_var.get().strip(),
            "username": username_var.get().strip(),
            "password": password_var.get().strip(),
        }
        _save_device_portal_settings(settings_config_state["path"], settings)
        return True

    settings_actions = ttk.Frame(settings_card, style="Content.TFrame")
    settings_actions.grid(row=4, column=0, columnspan=3, sticky="e", pady=(10, 0))
    ttk.Button(settings_actions, text="Save Settings", style="Ghost.TButton", command=save_portal_settings).grid(row=0, column=0)

    log_text = tk.Text(log_card, height=10, background=colors["panel"], foreground=colors["text"], insertbackground=colors["text"], borderwidth=0)
    log_text.configure(state="disabled")
    log_scroll = ttk.Scrollbar(log_card, orient=tk.VERTICAL, command=log_text.yview)
    log_text.configure(yscrollcommand=log_scroll.set)
    log_text.grid(row=0, column=0, sticky="nsew")
    log_scroll.grid(row=0, column=1, sticky="ns")

    pages["runner"] = runner_page

    # Packaging Page
    packaging_page = ttk.Frame(content, style="Content.TFrame")
    packaging_page.columnconfigure(0, weight=1)
    packaging_page.rowconfigure(2, weight=1)

    packaging_header_row = ttk.Frame(packaging_page, style="Content.TFrame")
    packaging_header_row.grid(row=0, column=0, sticky="ew")
    packaging_header_row.columnconfigure(0, weight=1)
    packaging_header_row.columnconfigure(1, weight=0)
    packaging_header = ttk.Label(packaging_header_row, text="Package MSIX", style="Header.TLabel")
    packaging_header.grid(row=0, column=0, sticky="w")
    packaging_hint = ttk.Label(packaging_header_row, text="Use makemsix to package a build folder.", style="Muted.TLabel")
    packaging_hint.grid(row=0, column=1, sticky="e")

    packaging_card = create_card(packaging_page, "makemsix")
    packaging_card.grid(row=1, column=0, sticky="ew", pady=(12, 8))

    packaging_log_card = create_card(packaging_page, "Output")
    packaging_log_card.grid(row=2, column=0, sticky="nsew")
    packaging_log_card.columnconfigure(0, weight=1)
    packaging_log_card.rowconfigure(0, weight=1)

    makemsix_tool_var = tk.StringVar(value=tool_db.get("makemsix", ""))
    packaging_build_var = tk.StringVar(value=str(Path.cwd()))
    packaging_output_var = tk.StringVar(value="")
    packaging_status = tk.StringVar(value="Select a build folder that contains AppxManifest.xml.")

    def update_packaging_state(path: Optional[Path]):
        if not path:
            packaging_status.set("Select a build folder that contains AppxManifest.xml.")
            return
        manifest_path = _find_appx_manifest(path)
        if not manifest_path:
            packaging_status.set("No AppxManifest.xml found in this folder.")
            return
        packaging_status.set(f"Manifest OK: {manifest_path.name}")
        if not packaging_output_var.get().strip():
            packaging_output_var.set(str(_suggest_msix_output(path)))

    def browse_makemsix():
        path = filedialog.askopenfilename()
        if path:
            makemsix_tool_var.set(path)
            _remember_tool_path("makemsix", path)

    def browse_packaging_build():
        path = filedialog.askdirectory()
        if path:
            packaging_build_var.set(path)
            update_packaging_state(Path(path))

    def browse_packaging_output():
        initial_dir = packaging_build_var.get().strip() or str(Path.cwd())
        initial_file = Path(packaging_output_var.get()).name if packaging_output_var.get().strip() else ""
        path = filedialog.asksaveasfilename(
            defaultextension=".msix",
            initialdir=initial_dir,
            initialfile=initial_file,
            filetypes=[("MSIX packages", "*.msix"), ("All files", "*.*")]
        )
        if path:
            packaging_output_var.set(path)

    def append_packaging_log(message: str):
        packaging_log_text.configure(state="normal")
        packaging_log_text.insert(tk.END, message.rstrip() + "\n")
        packaging_log_text.see(tk.END)
        packaging_log_text.configure(state="disabled")

    def run_packaging():
        build_dir_text = packaging_build_var.get().strip()
        output_text = packaging_output_var.get().strip()
        if not build_dir_text:
            messagebox.showerror("Missing build folder", "Select a build folder first.")
            return
        if not output_text:
            messagebox.showerror("Missing output", "Select an output .msix file.")
            return
        build_dir = Path(build_dir_text).expanduser().resolve()
        output_path = Path(output_text).expanduser().resolve()
        tool_path = makemsix_tool_var.get().strip()
        if tool_path:
            _remember_tool_path("makemsix", tool_path)
        ok, output = _run_makemsix(tool_path, build_dir, output_path)
        if output:
            append_packaging_log(output)
            print(output)
        if ok:
            messagebox.showinfo("MSIX created", f"MSIX created:\n{output_path}")
        else:
            messagebox.showerror("makemsix failed", output or "makemsix failed.")

    add_row(packaging_card, 0, "makemsix path", ttk.Entry(packaging_card, textvariable=makemsix_tool_var), ttk.Button(packaging_card, text="Browse", style="Ghost.TButton", command=browse_makemsix))
    add_row(packaging_card, 1, "Build folder", ttk.Entry(packaging_card, textvariable=packaging_build_var), ttk.Button(packaging_card, text="Browse", style="Ghost.TButton", command=browse_packaging_build))
    add_row(packaging_card, 2, "Output MSIX", ttk.Entry(packaging_card, textvariable=packaging_output_var), ttk.Button(packaging_card, text="Browse", style="Ghost.TButton", command=browse_packaging_output))
    ttk.Label(packaging_card, textvariable=packaging_status, style="Muted.TLabel").grid(row=3, column=0, columnspan=3, sticky="w", pady=(0, 6))

    packaging_actions = ttk.Frame(packaging_card, style="Content.TFrame")
    packaging_actions.grid(row=4, column=0, columnspan=3, sticky="e", pady=(6, 0))
    ttk.Button(packaging_actions, text="Package MSIX", style="Accent.TButton", command=run_packaging).grid(row=0, column=0, padx=(0, 8))
    ttk.Button(packaging_actions, text="Get makemsix", style="Ghost.TButton", command=lambda: webbrowser.open("https://github.com/microsoft/msix-packaging")).grid(row=0, column=1)

    packaging_log_text = tk.Text(packaging_log_card, height=10, background=colors["panel"], foreground=colors["text"], insertbackground=colors["text"], borderwidth=0)
    packaging_log_text.configure(state="disabled")
    packaging_log_scroll = ttk.Scrollbar(packaging_log_card, orient=tk.VERTICAL, command=packaging_log_text.yview)
    packaging_log_text.configure(yscrollcommand=packaging_log_scroll.set)
    packaging_log_text.grid(row=0, column=0, sticky="nsew")
    packaging_log_scroll.grid(row=0, column=1, sticky="ns")

    update_packaging_state(Path(packaging_build_var.get()))
    pages["packaging"] = packaging_page

    # Signing Page
    signing_page = ttk.Frame(content, style="Content.TFrame")
    signing_page.columnconfigure(0, weight=1)
    signing_page.rowconfigure(2, weight=1)

    signing_header_row = ttk.Frame(signing_page, style="Content.TFrame")
    signing_header_row.grid(row=0, column=0, sticky="ew")
    signing_header_row.columnconfigure(0, weight=1)
    signing_header_row.columnconfigure(1, weight=0)
    signing_header = ttk.Label(signing_header_row, text="Sign MSIX", style="Header.TLabel")
    signing_header.grid(row=0, column=0, sticky="w")
    signing_hint = ttk.Label(signing_header_row, text="Use osslsigncode to sign an MSIX package.", style="Muted.TLabel")
    signing_hint.grid(row=0, column=1, sticky="e")

    signing_card = create_card(signing_page, "osslsigncode sign")
    signing_card.grid(row=1, column=0, sticky="ew", pady=(12, 8))

    signing_log_card = create_card(signing_page, "Output")
    signing_log_card.grid(row=2, column=0, sticky="nsew")
    signing_log_card.columnconfigure(0, weight=1)
    signing_log_card.rowconfigure(0, weight=1)

    osslsigncode_tool_var = tk.StringVar(value=tool_db.get("osslsigncode", tool_db.get("osssigntiool", "")))
    pfx_path_var = tk.StringVar(value="")
    pfx_password_var = tk.StringVar(value="")
    app_name_var = tk.StringVar(value="")
    input_msix_var = tk.StringVar(value="")
    output_msix_var = tk.StringVar(value="")
    pfx_subject_var = tk.StringVar(value="CN=MyApp")

    def browse_osslsigncode():
        path = filedialog.askopenfilename()
        if path:
            osslsigncode_tool_var.set(path)
            _remember_tool_path("osslsigncode", path)

    def browse_pfx():
        path = filedialog.askopenfilename(filetypes=[("PFX certificate", "*.pfx"), ("All files", "*.*")])
        if path:
            pfx_path_var.set(path)

    def browse_input_msix():
        path = filedialog.askopenfilename(filetypes=[("MSIX packages", "*.msix"), ("All files", "*.*")])
        if path:
            input_msix_var.set(path)
            if not output_msix_var.get().strip():
                input_path = Path(path)
                output_msix_var.set(str(input_path.with_name(f"{input_path.stem}-signed.msix")))

    def browse_output_msix():
        initial_dir = str(Path(input_msix_var.get()).parent) if input_msix_var.get().strip() else str(Path.cwd())
        initial_file = Path(output_msix_var.get()).name if output_msix_var.get().strip() else ""
        path = filedialog.asksaveasfilename(
            defaultextension=".msix",
            initialdir=initial_dir,
            initialfile=initial_file,
            filetypes=[("MSIX packages", "*.msix"), ("All files", "*.*")]
        )
        if path:
            output_msix_var.set(path)

    def append_signing_log(message: str):
        signing_log_text.configure(state="normal")
        signing_log_text.insert(tk.END, message.rstrip() + "\n")
        signing_log_text.see(tk.END)
        signing_log_text.configure(state="disabled")

    def create_pfx():
        pfx_window = tk.Toplevel(root)
        pfx_window.title("Create PFX (OpenSSL)")
        pfx_window.geometry("620x360")
        pfx_window.resizable(True, False)

        frame = ttk.Frame(pfx_window, padding=16, style="Content.TFrame")
        frame.pack(fill=tk.BOTH, expand=True)
        frame.columnconfigure(1, weight=1)

        key_var = tk.StringVar(value="")
        cert_var = tk.StringVar(value="")
        days_var = tk.StringVar(value="365")
        subject_var = tk.StringVar(value=pfx_subject_var.get().strip() or "CN=Unknown")
        pfx_out_var = tk.StringVar(value="")
        password_var = tk.StringVar(value=pfx_password_var.get())

        def browse_path(var, ext_label):
            path = filedialog.asksaveasfilename(
                defaultextension=ext_label,
                filetypes=[(f"{ext_label.upper()} file", f"*{ext_label}"), ("All files", "*.*")]
            )
            if path:
                var.set(path)

        add_row(frame, 0, "Key output", ttk.Entry(frame, textvariable=key_var), ttk.Button(frame, text="Browse", style="Ghost.TButton", command=lambda: browse_path(key_var, ".pem")))
        add_row(frame, 1, "Cert output", ttk.Entry(frame, textvariable=cert_var), ttk.Button(frame, text="Browse", style="Ghost.TButton", command=lambda: browse_path(cert_var, ".pem")))
        add_row(frame, 2, "Days", ttk.Entry(frame, textvariable=days_var))
        add_row(frame, 3, "Subject", ttk.Entry(frame, textvariable=subject_var))
        add_row(frame, 4, "PFX output", ttk.Entry(frame, textvariable=pfx_out_var), ttk.Button(frame, text="Browse", style="Ghost.TButton", command=lambda: browse_path(pfx_out_var, ".pfx")))
        add_row(frame, 5, "PFX password", ttk.Entry(frame, textvariable=password_var, show="*"))

        command_preview = tk.StringVar(value="openssl req -x509 -newkey rsa:2048 -nodes -keyout ...")
        ttk.Label(frame, textvariable=command_preview, style="Muted.TLabel").grid(row=6, column=0, columnspan=3, sticky="w", pady=(8, 6))

        def update_preview(*_):
            command_preview.set(
                "openssl req -x509 -newkey rsa:2048 -nodes "
                f"-keyout {key_var.get().strip() or 'key.pem'} "
                f"-out {cert_var.get().strip() or 'cert.pem'} "
                f"-days {days_var.get().strip() or '365'} "
                f"-subj \"/{subject_var.get().strip() or 'CN=Unknown'}\" "
                "&& openssl pkcs12 -export "
                f"-out {pfx_out_var.get().strip() or 'cert.pfx'} "
                f"-inkey {key_var.get().strip() or 'key.pem'} "
                f"-in {cert_var.get().strip() or 'cert.pem'} "
                f"-passout pass:{password_var.get().strip() or 'password'}"
            )

        for var in (key_var, cert_var, days_var, subject_var, pfx_out_var, password_var):
            var.trace_add("write", update_preview)
        update_preview()

        actions = ttk.Frame(frame, style="Content.TFrame")
        actions.grid(row=7, column=0, columnspan=3, sticky="e", pady=(8, 0))

        def run_create():
            if not key_var.get().strip():
                messagebox.showerror("Missing key output", "Choose a key output path.")
                return
            if not cert_var.get().strip():
                messagebox.showerror("Missing cert output", "Choose a cert output path.")
                return
            if not pfx_out_var.get().strip():
                messagebox.showerror("Missing PFX output", "Choose a PFX output path.")
                return
            try:
                days = int(days_var.get().strip() or "365")
            except ValueError:
                messagebox.showerror("Invalid days", "Days must be a number.")
                return
            key_path = Path(key_var.get().strip()).expanduser().resolve()
            cert_path = Path(cert_var.get().strip()).expanduser().resolve()
            pfx_path = Path(pfx_out_var.get().strip()).expanduser().resolve()
            subject = subject_var.get().strip()
            password = password_var.get()
            ok, output = _create_pfx_with_openssl(key_path, cert_path, days, subject, pfx_path, password)
            if output:
                append_signing_log(output)
                print(output)
            if ok:
                pfx_path_var.set(str(pfx_path))
                pfx_password_var.set(password)
                pfx_subject_var.set(subject)
                messagebox.showinfo("PFX created", f"PFX created:\n{pfx_path}")
                pfx_window.destroy()
            else:
                messagebox.showerror("PFX creation failed", output or "Failed to create PFX.")

        ttk.Button(actions, text="Create", style="Accent.TButton", command=run_create).grid(row=0, column=0, padx=(0, 8))
        ttk.Button(actions, text="Cancel", style="Ghost.TButton", command=pfx_window.destroy).grid(row=0, column=1)

    def sign_msix():
        tool_path = osslsigncode_tool_var.get().strip()
        if tool_path:
            _remember_tool_path("osslsigncode", tool_path)
        cert_text = pfx_path_var.get().strip()
        input_text = input_msix_var.get().strip()
        output_text = output_msix_var.get().strip()
        app_name = app_name_var.get().strip()
        password = pfx_password_var.get()
        if not cert_text:
            messagebox.showerror("Missing PFX", "Select a .pfx certificate file.")
            return
        if not input_text:
            messagebox.showerror("Missing input", "Select an input .msix file.")
            return
        if not output_text:
            messagebox.showerror("Missing output", "Select an output .msix file.")
            return
        if not app_name:
            messagebox.showerror("Missing name", "Enter the app name for signing.")
            return
        if not password:
            messagebox.showerror("Missing password", "Enter the PFX password.")
            return
        cert_path = Path(cert_text).expanduser().resolve()
        input_path = Path(input_text).expanduser().resolve()
        output_path = Path(output_text).expanduser().resolve()
        ok, output = _run_osslsigncode(tool_path, cert_path, password, app_name, input_path, output_path)
        if output:
            append_signing_log(output)
            print(output)
        if ok:
            messagebox.showinfo("MSIX signed", f"Signed MSIX:\n{output_path}")
        else:
            messagebox.showerror("Signing failed", output or "osslsigncode failed.")

    add_row(signing_card, 0, "osslsigncode path", ttk.Entry(signing_card, textvariable=osslsigncode_tool_var), ttk.Button(signing_card, text="Browse", style="Ghost.TButton", command=browse_osslsigncode))
    add_row(signing_card, 1, "PFX file", ttk.Entry(signing_card, textvariable=pfx_path_var), ttk.Button(signing_card, text="Browse", style="Ghost.TButton", command=browse_pfx))
    add_row(signing_card, 2, "PFX password", ttk.Entry(signing_card, textvariable=pfx_password_var, show="*"))
    add_row(signing_card, 3, "Certificate subject", ttk.Entry(signing_card, textvariable=pfx_subject_var))
    add_row(signing_card, 4, "App name", ttk.Entry(signing_card, textvariable=app_name_var))
    add_row(signing_card, 5, "Input MSIX", ttk.Entry(signing_card, textvariable=input_msix_var), ttk.Button(signing_card, text="Browse", style="Ghost.TButton", command=browse_input_msix))
    add_row(signing_card, 6, "Output MSIX", ttk.Entry(signing_card, textvariable=output_msix_var), ttk.Button(signing_card, text="Browse", style="Ghost.TButton", command=browse_output_msix))

    signing_actions = ttk.Frame(signing_card, style="Content.TFrame")
    signing_actions.grid(row=7, column=0, columnspan=3, sticky="e", pady=(6, 0))
    ttk.Button(signing_actions, text="Create PFX", style="Ghost.TButton", command=create_pfx).grid(row=0, column=0, padx=(0, 8))
    ttk.Button(signing_actions, text="Sign MSIX", style="Accent.TButton", command=sign_msix).grid(row=0, column=1, padx=(0, 8))
    ttk.Button(signing_actions, text="Get osslsigncode", style="Ghost.TButton", command=lambda: webbrowser.open("https://github.com/mtrojnar/osslsigncode")).grid(row=0, column=2)

    signing_log_text = tk.Text(signing_log_card, height=10, background=colors["panel"], foreground=colors["text"], insertbackground=colors["text"], borderwidth=0)
    signing_log_text.configure(state="disabled")
    signing_log_scroll = ttk.Scrollbar(signing_log_card, orient=tk.VERTICAL, command=signing_log_text.yview)
    signing_log_text.configure(yscrollcommand=signing_log_scroll.set)
    signing_log_text.grid(row=0, column=0, sticky="nsew")
    signing_log_scroll.grid(row=0, column=1, sticky="ns")

    pages["signing"] = signing_page

    add_nav_button("create", "New Project")
    add_nav_button("editor", "Editor")
    add_nav_button("runner", "Installer")
    add_nav_button("packaging", "Packaging")
    add_nav_button("signing", "Signing")

    show_page("create")

    root.mainloop()

def edit_project_config_gui(config_path: Path, parent=None) -> None:
    data = _load_config(config_path)
    project_dir = _resolve_project_dir(config_path, data)
    manifest_paths = _get_manifest_paths(project_dir)
    current_caps = set()
    if manifest_paths:
        current_caps = _read_manifest_capabilities(manifest_paths[0])

    try:
        import tkinter as tk
        from tkinter import ttk, filedialog, messagebox
    except Exception as exc:
        _error(f"Failed to start GUI: {exc}")
        sys.exit(1)

    owning_root = parent is None
    root = tk.Tk() if owning_root else tk.Toplevel(parent)
    root.title("MinGW WinRT Project Editor")
    root.geometry("800x760")
    root.resizable(True, True)
    _apply_vs_style(root)

    header = ttk.Label(root, text="Edit MinGW WinRT project", font=("Segoe UI", 14, "bold"))
    header.pack(pady=(16, 6))
    subtitle = ttk.Label(root, text=str(config_path))
    subtitle.pack(pady=(0, 10))

    canvas = tk.Canvas(root, highlightthickness=0)
    scrollbar = ttk.Scrollbar(root, orient=tk.VERTICAL, command=canvas.yview)
    canvas.configure(yscrollcommand=scrollbar.set)

    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

    frame = ttk.Frame(canvas, padding=16)
    frame_id = canvas.create_window((0, 0), window=frame, anchor="nw")

    def _on_frame_configure(event):
        canvas.configure(scrollregion=canvas.bbox("all"))

    def _on_canvas_configure(event):
        canvas.itemconfig(frame_id, width=event.width)

    frame.bind("<Configure>", _on_frame_configure)
    canvas.bind("<Configure>", _on_canvas_configure)

    def add_row(row, label_text, widget, button=None):
        label = ttk.Label(frame, text=label_text)
        label.grid(row=row, column=0, sticky="w", pady=6)
        widget.grid(row=row, column=1, sticky="ew", padx=(8, 0), pady=6)
        if button is not None:
            button.grid(row=row, column=2, sticky="e", padx=(8, 0), pady=6)

    frame.columnconfigure(1, weight=1)

    name_var = tk.StringVar(value=data.get('name', project_dir.name))
    name_entry = ttk.Entry(frame, textvariable=name_var, state="disabled")

    project_dir_var = tk.StringVar(value=str(project_dir))
    project_dir_entry = ttk.Entry(frame, textvariable=project_dir_var, state="disabled")

    arch_var = tk.StringVar(value=data.get('arch', 'x64'))
    arch_combo = ttk.Combobox(frame, textvariable=arch_var, state="readonly")
    arch_combo["values"] = ARCH_CHOICES

    publisher_var = tk.StringVar(value=data.get('publisher', 'CN=Unknown'))
    publisher_entry = ttk.Entry(frame, textvariable=publisher_var)

    resources_var = tk.StringVar(value=data.get('resourcesDir', ''))
    resources_entry = ttk.Entry(frame, textvariable=resources_var)
    resources_button = ttk.Button(frame, text="Browse", command=lambda: resources_var.set(filedialog.askdirectory() or resources_var.get()))

    images = data.get('images', {}) or {}
    icon_var = tk.StringVar(value=images.get('icon', ''))
    icon_entry = ttk.Entry(frame, textvariable=icon_var)
    icon_button = ttk.Button(frame, text="Browse", command=lambda: icon_var.set(filedialog.askopenfilename() or icon_var.get()))

    banner_var = tk.StringVar(value=images.get('banner', ''))
    banner_entry = ttk.Entry(frame, textvariable=banner_var)
    banner_button = ttk.Button(frame, text="Browse", command=lambda: banner_var.set(filedialog.askopenfilename() or banner_var.get()))

    include_msvc_var = tk.BooleanVar(value=bool(data.get('includeMsvcDlls', False)))

    add_row(0, "Project name", name_entry)
    add_row(1, "Project directory", project_dir_entry)
    add_row(2, "Architecture", arch_combo)
    add_row(3, "Publisher", publisher_entry)
    add_row(4, "Resources directory", resources_entry, resources_button)
    add_row(5, "Icon image", icon_entry, icon_button)
    add_row(6, "Banner image", banner_entry, banner_button)
    ttk.Checkbutton(frame, text="Include MSVC DLLs in deps/bin", variable=include_msvc_var).grid(row=7, column=1, sticky="w", pady=(4, 6))

    cap_frame = ttk.Labelframe(frame, text="Capabilities", padding=12)
    cap_frame.grid(row=8, column=0, columnspan=3, sticky="ew", pady=(10, 6))
    cap_frame.columnconfigure(0, weight=1)
    cap_frame.columnconfigure(1, weight=1)

    cap_vars = {}
    caps_list = list(STANDARD_CAPS) + list(RESTRICTED_CAPS)
    for idx, cap in enumerate(caps_list):
        cap_vars[cap] = tk.BooleanVar(value=cap in current_caps)
        row = idx // 2
        col = idx % 2
        ttk.Checkbutton(cap_frame, text=cap, variable=cap_vars[cap]).grid(row=row, column=col, sticky="w", padx=4, pady=2)

    optional_frame = ttk.Labelframe(frame, text="Optional capabilities", padding=12)
    optional_frame.grid(row=9, column=0, columnspan=3, sticky="ew", pady=(6, 6))
    optional_frame.columnconfigure(1, weight=1)

    optional_selected = [cap for cap in OPTIONAL_CAPS if cap in current_caps]
    optional_var = tk.StringVar(value=OPTIONAL_CAPS[0] if OPTIONAL_CAPS else '')
    optional_combo = ttk.Combobox(optional_frame, textvariable=optional_var, state="readonly")
    optional_combo["values"] = OPTIONAL_CAPS

    optional_list = tk.Listbox(optional_frame, height=4)
    for cap in optional_selected:
        optional_list.insert(tk.END, cap)

    def add_optional():
        cap = optional_var.get()
        if not cap:
            return
        items = set(optional_list.get(0, tk.END))
        if cap not in items:
            optional_list.insert(tk.END, cap)

    def remove_optional():
        selection = optional_list.curselection()
        if not selection:
            return
        for idx in reversed(selection):
            optional_list.delete(idx)

    ttk.Label(optional_frame, text="Add capability").grid(row=0, column=0, sticky="w", pady=4)
    optional_combo.grid(row=0, column=1, sticky="ew", padx=(8, 0), pady=4)
    ttk.Button(optional_frame, text="Add", command=add_optional).grid(row=0, column=2, sticky="e", padx=(8, 0), pady=4)
    ttk.Label(optional_frame, text="Selected").grid(row=1, column=0, sticky="nw", pady=4)
    optional_list.grid(row=1, column=1, sticky="ew", padx=(8, 0), pady=4)
    ttk.Button(optional_frame, text="Remove", command=remove_optional).grid(row=1, column=2, sticky="ne", padx=(8, 0), pady=4)

    button_frame = ttk.Frame(root, padding=(16, 0, 16, 16))
    button_frame.pack(fill=tk.X)
    button_frame.columnconfigure(0, weight=1)

    def on_save():
        updated = dict(data)
        updated['name'] = name_var.get()
        updated['arch'] = arch_var.get()
        updated['publisher'] = publisher_var.get().strip() or 'CN=Unknown'
        updated['resourcesDir'] = resources_var.get().strip()
        updated['projectDir'] = project_dir_var.get()
        updated['images'] = {
            'icon': icon_var.get().strip(),
            'banner': banner_var.get().strip()
        }
        updated['includeMsvcDlls'] = bool(include_msvc_var.get())

        selected_caps = {cap for cap, var in cap_vars.items() if var.get()}
        selected_caps.update(optional_list.get(0, tk.END))
        updated['capabilities'] = sorted(selected_caps)

        _save_config(config_path, updated)
        _update_metadata(project_dir, updated['arch'])
        _update_manifest_publisher(project_dir, updated['publisher'])
        if manifest_paths:
            _update_manifest_capabilities(project_dir, set(selected_caps))
        _sync_images(project_dir, updated['resourcesDir'], updated['images']['icon'], updated['images']['banner'])
        if updated['includeMsvcDlls'] and project_dir.exists():
            _ensure_deps_layout(project_dir)
            _copy_msvc_dlls(project_dir, updated['arch'])

        messagebox.showinfo("Saved", f"Updated config: {config_path}")
        root.destroy()

    ttk.Button(button_frame, text="Save", command=on_save).grid(row=0, column=1, sticky="e")
    ttk.Button(button_frame, text="Cancel", command=root.destroy).grid(row=0, column=2, sticky="e", padx=(8, 0))

    if owning_root:
        root.mainloop()

def _run_makemsix_cli(argv) -> None:
    parser = argparse.ArgumentParser(
        description="Package MSIX using makemsix (requires pack-capable build)."
    )
    parser.add_argument("build_dir", help="Directory containing AppxManifest.xml")
    parser.add_argument("-o", "--output", default="", help="Output .msix path (optional)")
    parser.add_argument("--makemsix", default="", help="Path to makemsix executable (optional)")
    args = parser.parse_args(argv)

    build_dir = Path(args.build_dir).expanduser().resolve()
    manifest_path = _find_appx_manifest(build_dir)
    if not manifest_path:
        _error(f"AppxManifest.xml not found in {build_dir}")
        sys.exit(1)

    output_path = Path(args.output).expanduser().resolve() if args.output else _suggest_msix_output(build_dir)
    tool_db = _load_tool_db()
    tool_path = args.makemsix or tool_db.get("makemsix", "")
    if args.makemsix:
        _remember_tool_path("makemsix", args.makemsix)

    ok, output = _run_makemsix(tool_path, build_dir, output_path)
    if output:
        print(output)
    if ok:
        _success(f"MSIX created: {output_path}")
        return
    _error("makemsix failed.")
    sys.exit(1)

def _run_install_cli(argv) -> None:
    parser = argparse.ArgumentParser(
        description="Run/register loose builds or install MSIX/AppX packages.",
        epilog=(
            "Remote deploy requires --json with ip/username/password under devicePortal.\n"
            "Loose remote deploy requires a UNC path (\\\\host\\share\\path)."
        ),
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument("build_dir", help="Directory containing AppxManifest.xml")
    parser.add_argument("--no-launch", action="store_true", help="Do not launch after registering")
    parser.add_argument("--remote", action="store_true", help="Deploy to a remote device portal")
    parser.add_argument("--json", default="", help="Path to mingw_winrt.json with device portal credentials")
    parser.add_argument("--logs", action="store_true", help="Print recent runtime logs after install/run")
    parser.add_argument("--debug", action="store_true", help="Print recent debug output (Windows only)")
    parser.add_argument("--crashes", action="store_true", help="Print recent crash events (Windows only)")
    parser.add_argument("--minutes", type=int, default=10, help="Minutes to look back for logs (default 10)")
    args = parser.parse_args(argv)

    build_dir = Path(args.build_dir).expanduser().resolve()
    if build_dir.is_file():
        if build_dir.suffix.lower() not in ('.msix', '.msixbundle', '.appx', '.appxbundle'):
            _error("Unsupported package type. Use .msix, .msixbundle, .appx, or .appxbundle.")
            sys.exit(1)
        if args.remote:
            if not args.json:
                _error("--json is required for remote deploy.")
                sys.exit(1)
            json_path = Path(args.json).expanduser().resolve()
            if not json_path.exists():
                _error(f"Config not found: {json_path}")
                sys.exit(1)
            portal = _load_device_portal_from_json(json_path)
            ip = portal.get("ip", "")
            username = portal.get("username", "")
            password = portal.get("password", "")
            if not ip or not username or not password:
                _error("JSON must include ip, username, and password.")
                sys.exit(1)
            _info("Deploying MSIX package to device portal...")
            ok, output = _deploy_msix_remote(build_dir, ip, username, password)
            if output:
                print(output)
            if ok:
                _success("Remote install accepted.")
                return
            _error("Remote MSIX deploy failed.")
            sys.exit(1)

        _info("Installing MSIX locally...")
        ok, output = _install_msix_local(build_dir)
        if output:
            print(output)
        if ok:
            _success("Install completed.")
            return
        _error("MSIX install failed.")
        sys.exit(1)
    manifest_path = _find_appx_manifest(build_dir)
    if not manifest_path:
        _error(f"AppxManifest.xml not found in {build_dir}")
        sys.exit(1)

    if args.remote:
        if not args.json:
            _error("--json is required for remote deploy.")
            sys.exit(1)
        json_path = Path(args.json).expanduser().resolve()
        if not json_path.exists():
            _error(f"Config not found: {json_path}")
            sys.exit(1)
        portal = _load_device_portal_from_json(json_path)
        ip = portal.get("ip", "")
        username = portal.get("username", "")
        password = portal.get("password", "")
        if not ip or not username or not password:
            _error("JSON must include ip, username, and password.")
            sys.exit(1)
        share_path = str(build_dir)
        if not (share_path.startswith("\\\\") or share_path.startswith("//")):
            _error("Remote deploy requires a UNC path (\\\\host\\share\\path).")
            sys.exit(1)
        _info("Deploying loose folder to device portal...")
        ok, output = _deploy_loose_remote(share_path, ip, username, password)
        if output:
            print(output)
        if ok:
            _success("Remote deploy accepted.")
            return
        _error("Remote deploy failed.")
        sys.exit(1)

    _info("Registering AppxManifest.xml locally...")
    ok, output = _register_appx(manifest_path)
    if output:
        print(output)
    if not ok:
        _error("Registration failed.")
        sys.exit(1)
    _success("Registration completed.")

    identity_name, app_id = _read_manifest_identity(manifest_path)

    if args.no_launch:
        if args.logs or args.debug or args.crashes:
            if args.logs:
                logs = _collect_runtime_logs(identity_name, minutes=args.minutes)
                if logs:
                    print("\n=== Runtime Logs ===")
                    print(logs)
            if args.debug:
                debug_logs = _collect_debug_output(identity_name, minutes=args.minutes)
                if debug_logs:
                    print("\n=== Debug Output ===")
                    print(debug_logs)
            if args.crashes:
                crash_logs = _collect_crash_logs(identity_name, minutes=max(args.minutes, 10))
                if crash_logs:
                    print("\n=== Crash Logs ===")
                    print(crash_logs)
        return

    _info("Launching app...")
    launch_ok, launch_output = _launch_app(identity_name, app_id)
    if launch_output:
        print(launch_output)
    if not launch_ok:
        _error("Failed to launch app.")
        sys.exit(1)

    if not (args.logs or args.debug or args.crashes):
        logs = _collect_runtime_logs(identity_name, minutes=10)
        if logs:
            print("\n=== Runtime Logs ===")
            print(logs)
        return

    if args.logs:
        logs = _collect_runtime_logs(identity_name, minutes=args.minutes)
        if logs:
            print("\n=== Runtime Logs ===")
            print(logs)

    if args.debug:
        debug_logs = _collect_debug_output(identity_name, minutes=args.minutes)
        if debug_logs:
            print("\n=== Debug Output ===")
            print(debug_logs)

    if args.crashes:
        crash_logs = _collect_crash_logs(identity_name, minutes=max(args.minutes, 10))
        if crash_logs:
            print("\n=== Crash Logs ===")
            print(crash_logs)

def main():
    parser = argparse.ArgumentParser(description='Generate MinGW UWP projects (loose files)')
    parser.add_argument('type', choices=['library', 'console', 'xaml', 'corewindow'], help='Project type')
    parser.add_argument('name', help='Project name')
    parser.add_argument('--template-dir', default=str(Path(__file__).parent.parent / 'templates'), help='Templates directory')
    parser.add_argument('--output-dir', default='.', help='Output directory (will create a folder with project name)')
    parser.add_argument('--arch', default='x64', help='Target architecture (x64/x86/arm64/arm)')
    parser.add_argument('--publisher', default='CN=Unknown', help='Publisher CN for manifest')
    parser.add_argument('--overwrite', action='store_true', help='Overwrite output directory if it exists')
    parser.add_argument('--include-msvc-dlls', action='store_true', help='Copy MSVC runtime DLLs into deps/bin')

    force_cli = '--cli' in sys.argv
    if force_cli:
        sys.argv.remove('--cli')
    if '--gui' in sys.argv:
        sys.argv.remove('--gui')

    if len(sys.argv) == 1:
        repo_root = Path(__file__).parent.parent
        images_dir = repo_root / 'Images'
        launch_gui(
            default_template_dir=Path(parser.get_default('template_dir')).expanduser().resolve(),
            default_output_dir=Path(parser.get_default('output_dir')).expanduser().resolve(),
            default_arch=parser.get_default('arch'),
            default_publisher=parser.get_default('publisher'),
            images_dir=images_dir,
        )
        return

    if len(sys.argv) >= 2:
        first = sys.argv[1].lower()
        if first == "makemsix":
            if len(sys.argv) < 3:
                _error("Missing build directory for makemsix.")
                sys.exit(1)
            _run_makemsix_cli(sys.argv[2:])
            return
        if first in RUN_ALIASES:
            if len(sys.argv) < 3:
                _error("Missing build directory for run/install.")
                sys.exit(1)
            _run_install_cli(sys.argv[2:])
            return
        if len(sys.argv) == 2 and Path(sys.argv[1]).is_dir():
            _run_install_cli(sys.argv[1:])
            return
        if len(sys.argv) >= 3 and Path(sys.argv[2]).is_dir() and first not in ('library', 'console', 'xaml', 'corewindow'):
            _run_install_cli(sys.argv[2:])
            return

    json_args = [arg for arg in sys.argv[1:] if arg.lower().endswith('.json')]
    if json_args:
        maybe_config = Path(json_args[0])
        if maybe_config.exists():
            if force_cli:
                edit_project_config(maybe_config.resolve())
            else:
                edit_project_config_gui(maybe_config.resolve())
            return

    args = parser.parse_args()

    repo_root = Path(__file__).parent.parent
    template_dir = Path(args.template_dir)
    out_dir = Path(args.output_dir).resolve() / args.name
    images_dir = repo_root / 'Images'

    generate_project(template_dir, args.type, args.name, out_dir, args.arch, args.publisher, images_dir, args.overwrite, args.include_msvc_dlls)

if __name__ == '__main__':
    main()
