#!/usr/bin/env python3
import argparse
import shutil
import uuid
import tempfile
import os
from pathlib import Path
import re
import json
import sys
from typing import Optional
from xml.etree import ElementTree as ET

try:
    from PIL import Image
except Exception:
    Image = None

TEXT_EXTENSIONS = {'.txt', '.in', '.xml', '.xaml', '.cpp', '.h', '.hpp', '.c', '.cmake', 'CMakeLists.txt', '.md'}
DEFAULT_CONFIG_NAME = 'mingw_winrt.json'
ARCH_CHOICES = ('x64', 'x86', 'arm64', 'arm')
MSVC_DLLS = (
    'msvcp140_app.dll',
    'vcruntime140_app.dll',
    'vcruntime140_1_app.dll',
)
REPO_ROOT = Path(__file__).parent.parent
NAMESPACE_URIS = {
    'foundation': 'http://schemas.microsoft.com/appx/manifest/foundation/windows10',
    'uap': 'http://schemas.microsoft.com/appx/manifest/uap/windows10',
    'rescap': 'http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities',
}
CAPABILITY_DEFS = {
    'internetClient': 'foundation',
    'internetClientServer': 'foundation',
    'privateNetworkClientServer': 'foundation',
    'enterpriseAuthentication': 'foundation',
    'sharedUserCertificates': 'foundation',
    'removableStorage': 'uap',
    'documentsLibrary': 'uap',
    'picturesLibrary': 'uap',
    'videosLibrary': 'uap',
    'musicLibrary': 'uap',
    'location': 'uap',
    'microphone': 'uap',
    'webcam': 'uap',
    'userAccountInformation': 'uap',
    'contacts': 'uap',
    'appointments': 'uap',
    'codeGeneration': 'rescap',
    'broadFileSystemAccess': 'rescap',
    'runFullTrust': 'rescap',
}
STANDARD_CAPS = (
    'internetClient',
    'internetClientServer',
    'privateNetworkClientServer',
    'removableStorage',
    'documentsLibrary',
    'picturesLibrary',
    'videosLibrary',
    'musicLibrary',
    'location',
    'microphone',
    'webcam',
)
RESTRICTED_CAPS = (
    'codeGeneration',
    'broadFileSystemAccess',
    'runFullTrust',
)
OPTIONAL_CAPS = (
    'enterpriseAuthentication',
    'sharedUserCertificates',
    'userAccountInformation',
    'contacts',
    'appointments',
)

def _supports_color() -> bool:
    if not sys.stdout.isatty():
        return False
    term = os.environ.get('TERM', '')
    return term != 'dumb'

def _color(text: str, code: str) -> str:
    if not _supports_color():
        return text
    return f"\033[{code}m{text}\033[0m"

def _info(text: str) -> None:
    print(_color(text, '36'))

def _success(text: str) -> None:
    print(_color(text, '32'))

def _warn(text: str) -> None:
    print(_color(text, '33'))

def _error(text: str) -> None:
    print(_color(text, '31'))

def sanitize_namespace(name: str) -> str:
    s = re.sub(r'[^0-9A-Za-z_]', '', name)
    if not s:
        return 'App'
    if s[0].isdigit():
        s = '_' + s
    return s

def is_text_file(path: Path) -> bool:
    ext = path.suffix
    if path.name == 'CMakeLists.txt':
        return True
    return ext in TEXT_EXTENSIONS

def replace_in_file(path: Path, replacements):
    try:
        text = path.read_text(encoding='utf-8')
    except Exception:
        return
    original = text
    for old, new in replacements.items():
        text = text.replace(old, new)
    guid_regex = re.compile(r'[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}')
    def guid_replacer(match):
        return str(uuid.uuid4())
    text = guid_regex.sub(guid_replacer, text)
    if text != original:
        path.write_text(text, encoding='utf-8')

def _write_project_readme(out_dir: Path, project_name: str, project_type: str) -> None:
    extra_install = ""
    if project_type in ('xaml', 'corewindow'):
        extra_install = "\nFast register (dev loop):\n\n```powershell\n" \
                        "powershell.exe -Command Add-AppxPackage -Register .\\AppxManifest.xml\n" \
                        "```\n"

    readme = f"""# {project_name}

Generated by the MinGW WinRT project generator.

## Build

```powershell
cmake -S . -B build
cmake --build build
```

## Package (Appx/MSIX)

```powershell
cmake --build build --target appx
cmake --build build --target msix
```

Outputs will be in `build/{project_name}.appx` or `build/{project_name}.msix`.

## Install

```powershell
powershell.exe -NoProfile -ExecutionPolicy Bypass -File .\install.ps1 -Package .\build\{project_name}.appx
```

If you have the Windows 10/11 SDK installed, `makeappx.exe` is used for packaging.
{extra_install}
"""
    (out_dir / 'README.md').write_text(readme, encoding='utf-8')

def _write_install_script(out_dir: Path, project_name: str) -> None:
    script = f"""param(
    [string]$Package = ""
)

$ErrorActionPreference = "Stop"

if (-not $Package) {{
    if (Test-Path ".\build\{project_name}.msix") {{
        $Package = ".\build\{project_name}.msix"
    }} elseif (Test-Path ".\build\{project_name}.appx") {{
        $Package = ".\build\{project_name}.appx"
    }} else {{
        Write-Host "Package not found. Build and package first." -ForegroundColor Red
        exit 1
    }}
}}

Write-Host "Installing $Package" -ForegroundColor Cyan
Add-AppxPackage -Path $Package
"""
    (out_dir / 'install.ps1').write_text(script, encoding='utf-8')

def _ensure_deps_layout(out_dir: Path) -> None:
    for sub in ('bin', 'include', 'lib'):
        (out_dir / 'deps' / sub).mkdir(parents=True, exist_ok=True)

def _arch_folder(arch: str) -> str:
    return {
        'x64': 'x64',
        'x86': 'x86',
        'arm64': 'arm64',
        'arm': 'arm',
    }.get(arch, arch)

def _find_msvc_redist_dir(arch: str) -> Optional[Path]:
    repo_msvc = REPO_ROOT / 'MSVC'
    if repo_msvc.exists():
        return repo_msvc
    return None

def _copy_msvc_dlls(out_dir: Path, arch: str) -> None:
    redist_dir = _find_msvc_redist_dir(arch)
    if not redist_dir:
        _warn("âš ï¸  MSVC redist not found; skipping MSVC DLL copy.")
        return
    dest = out_dir / 'deps' / 'bin'
    dest.mkdir(parents=True, exist_ok=True)
    any_copied = False
    for dll in MSVC_DLLS:
        src = redist_dir / dll
        if src.exists():
            shutil.copy2(src, dest / dll)
            any_copied = True
        else:
            _warn(f"âš ï¸  Missing MSVC DLL: {src}")
    if not any_copied:
        _warn(f"âš ï¸  No specified MSVC DLLs were found in {redist_dir}; nothing was copied.")

def _get_manifest_paths(project_dir: Path) -> list:
    paths = []
    for name in ('AppxManifest.in', 'AppxManifest.xml'):
        path = project_dir / name
        if path.exists():
            paths.append(path)
    return paths

def _local_name(tag: str) -> str:
    if tag.startswith('{'):
        return tag.split('}', 1)[1]
    return tag

def _root_namespace(tag: str) -> str:
    if tag.startswith('{'):
        return tag.split('}', 1)[0].strip('{')
    return ''

def _read_manifest_capabilities(path: Path) -> set:
    try:
        tree = ET.parse(path)
    except Exception:
        return set()
    root = tree.getroot()
    caps = set()
    for elem in root.iter():
        if _local_name(elem.tag) != 'Capability':
            continue
        name = elem.attrib.get('Name')
        if name:
            caps.add(name)
    return caps

def _ensure_ignorable_namespaces(root: ET.Element, prefixes: set) -> None:
    existing = root.attrib.get('IgnorableNamespaces', '')
    current = [p for p in existing.split(' ') if p]
    merged = set(current) | set(prefixes)
    if merged:
        root.set('IgnorableNamespaces', ' '.join(sorted(merged)))

def _update_manifest_capabilities_file(path: Path, selected_caps: set) -> None:
    try:
        tree = ET.parse(path)
    except Exception:
        return

    root = tree.getroot()
    foundation_ns = _root_namespace(root.tag) or NAMESPACE_URIS['foundation']

    ET.register_namespace('', foundation_ns)
    ET.register_namespace('uap', NAMESPACE_URIS['uap'])
    ET.register_namespace('rescap', NAMESPACE_URIS['rescap'])

    caps_parent = None
    for child in list(root):
        if _local_name(child.tag) == 'Capabilities':
            caps_parent = child
            break
    if caps_parent is None:
        caps_parent = ET.Element(f"{{{foundation_ns}}}Capabilities")
        root.append(caps_parent)

    known_caps = set(CAPABILITY_DEFS.keys())
    existing_caps = set()

    for parent in root.iter():
        for child in list(parent):
            if _local_name(child.tag) != 'Capability':
                continue
            cap_name = child.attrib.get('Name')
            if not cap_name:
                continue
            existing_caps.add(cap_name)
            if cap_name in known_caps and cap_name not in selected_caps:
                parent.remove(child)

    needed_prefixes = set()
    for cap_name in selected_caps:
        if cap_name in existing_caps:
            continue
        ns_key = CAPABILITY_DEFS.get(cap_name, 'foundation')
        if ns_key == 'foundation':
            ns_uri = foundation_ns
        else:
            ns_uri = NAMESPACE_URIS.get(ns_key, foundation_ns)
            needed_prefixes.add(ns_key)
        cap_el = ET.Element(f"{{{ns_uri}}}Capability")
        cap_el.set('Name', cap_name)
        caps_parent.append(cap_el)

    if needed_prefixes:
        _ensure_ignorable_namespaces(root, needed_prefixes)

    tree.write(path, encoding='utf-8', xml_declaration=True)

def _update_manifest_capabilities(project_dir: Path, selected_caps: set) -> None:
    for path in _get_manifest_paths(project_dir):
        _update_manifest_capabilities_file(path, selected_caps)

def _write_project_config(out_dir: Path, project_type: str, project_name: str, arch: str, publisher: str, include_msvc_dlls: bool) -> Path:
    config = {
        'name': project_name,
        'type': project_type,
        'arch': arch,
        'publisher': publisher or 'CN=Unknown',
        'projectDir': str(out_dir),
        'resourcesDir': '',
        'images': {
            'icon': '',
            'banner': ''
        },
        'capabilities': [],
        'includeMsvcDlls': include_msvc_dlls,
        'version': 1
    }
    config_path = out_dir / DEFAULT_CONFIG_NAME
    config_path.write_text(json.dumps(config, indent=2), encoding='utf-8')
    return config_path

def copy_tree(src: Path, dst: Path, replacements, skip_binary_replace=True):
    for root, dirs, files in os.walk(src):
        rel = Path(root).relative_to(src)
        target_dir = dst.joinpath(rel)
        target_dir.mkdir(parents=True, exist_ok=True)
        for f in files:
            s = Path(root) / f
            d = target_dir / f
            shutil.copy2(s, d)
            if is_text_file(s):
                replace_in_file(d, replacements)

def generate_project(template_dir: Path, project_type: str, project_name: str, out_dir: Path, arch: str, publisher: str, reuse_images: Optional[Path], overwrite: bool, include_msvc_dlls: bool):
    if out_dir.exists() and any(out_dir.iterdir()) and not overwrite:
        raise FileExistsError(f"Output directory {out_dir} exists and is not empty (use --overwrite).")

    tmp = Path(tempfile.mkdtemp(prefix='mingw_uwp_'))
    try:
        staging = tmp / project_name
        staging.mkdir()

        src_template = template_dir / project_type
        if not src_template.exists():
            raise FileNotFoundError(f"Template for '{project_type}' not found in {template_dir}")

        replacements = {
            '__PROJECT_NAME__': project_name,
            'CoreAppMinGW': project_name,
            '__PROJECT_NAMESPACE__': sanitize_namespace(project_name),
            '__PUBLISHER__': publisher or 'CN=Unknown',
            'CN=Unknown': publisher or 'CN=Unknown'
        }

        copy_tree(src_template, staging, replacements)

        if project_type in ('xaml', 'corewindow') and reuse_images and reuse_images.exists():
            dest_images = staging / 'Images'
            shutil.copytree(reuse_images, dest_images, dirs_exist_ok=True)

        for p in staging.rglob('*'):
            if p.is_file() and is_text_file(p):
                replace_in_file(p, replacements)

        meta = {
            'project': project_name,
            'namespace': sanitize_namespace(project_name),
            'arch': arch,
            'guid_generated': str(uuid.uuid4())
        }
        (staging / 'metadata.json').write_text(json.dumps(meta, indent=2), encoding='utf-8')

        if out_dir.exists() and out_dir.is_dir():
            shutil.rmtree(out_dir)
        shutil.move(str(staging), str(out_dir))
        _ensure_deps_layout(out_dir)
        if include_msvc_dlls:
            _copy_msvc_dlls(out_dir, arch)
        _write_project_config(out_dir, project_type, project_name, arch, publisher, include_msvc_dlls)
        _write_project_readme(out_dir, project_name, project_type)
        _write_install_script(out_dir, project_name)
        _success(f"Project created: {out_dir}")
    finally:
        try:
            if tmp.exists():
                shutil.rmtree(tmp)
        except Exception:
            pass

def _load_config(path: Path) -> dict:
    try:
        data = json.loads(path.read_text(encoding='utf-8'))
    except FileNotFoundError:
        _error(f"âŒ Configuration file not found: {path}")
        sys.exit(1)
    except json.JSONDecodeError as exc:
        _error(f"âŒ Error parsing config file: {exc}")
        sys.exit(1)
    return data

def _save_config(path: Path, data: dict) -> None:
    path.write_text(json.dumps(data, indent=2), encoding='utf-8')

def _prompt(text: str, current: str) -> str:
    value = input(f"{text} [{current}]: ").strip()
    if value == '-':
        return ''
    return value or current

def _prompt_choice(text: str, current: str, choices) -> str:
    choices_str = "/".join(choices)
    value = input(f"{text} ({choices_str}) [{current}]: ").strip().lower()
    if not value:
        return current
    if value not in choices:
        _warn(f"âš ï¸  Invalid choice '{value}', keeping '{current}'.")
        return current
    return value

def _prompt_capabilities(current_caps: set) -> set:
    known_caps = sorted(CAPABILITY_DEFS.keys())
    _info("Known capabilities: " + ", ".join(known_caps))
    value = input("Enable capabilities (comma-separated, '-' to clear, blank to keep): ").strip()
    if not value:
        return current_caps
    if value == '-':
        return set()
    requested = {v.strip() for v in value.split(',') if v.strip()}
    enabled = {cap for cap in requested if cap in known_caps}
    unknown = requested - enabled
    if unknown:
        _warn("âš ï¸  Unknown capabilities ignored: " + ", ".join(sorted(unknown)))
    return enabled

def _resolve_project_dir(config_path: Path, data: dict) -> Path:
    project_dir = data.get('projectDir')
    if project_dir:
        return Path(project_dir).expanduser().resolve()
    return config_path.parent.resolve()

def _update_manifest_publisher(project_dir: Path, publisher: str) -> None:
    for name in ('AppxManifest.in', 'AppxManifest.xml'):
        path = project_dir / name
        if not path.exists():
            continue
        try:
            text = path.read_text(encoding='utf-8')
        except Exception:
            continue
        updated = re.sub(r'Publisher="[^"]*"', f'Publisher="{publisher}"', text)
        if updated != text:
            path.write_text(updated, encoding='utf-8')

def _update_metadata(project_dir: Path, arch: str) -> None:
    path = project_dir / 'metadata.json'
    if not path.exists():
        return
    try:
        data = json.loads(path.read_text(encoding='utf-8'))
    except Exception:
        return
    data['arch'] = arch
    path.write_text(json.dumps(data, indent=2), encoding='utf-8')

def _is_valid_aspect_ratio(w: int, h: int) -> bool:
    if h == 0:
        return False
    ratio = w / h
    return 1.6 <= ratio <= 2.4

def _get_target_size(path: Path, fallback: tuple) -> tuple:
    if Image is None:
        return fallback
    if path.exists():
        try:
            with Image.open(path) as img:
                return img.size
        except Exception:
            return fallback
    return fallback

def _sync_images(project_dir: Path, resources_dir: str, icon_path: str, banner_path: str) -> None:
    if Image is None:
        _warn("âš ï¸  Pillow not installed; skipping image updates.")
        return

    images_dir = project_dir / 'Images'
    if not images_dir.exists():
        _warn(f"âš ï¸  Images directory not found at {images_dir}")
        return

    resources_path = Path(resources_dir).expanduser().resolve() if resources_dir else None

    icon_candidates = []
    banner_candidates = []
    if resources_path and resources_path.exists():
        icon_candidates = [
            resources_path / 'icon.png',
            resources_path / 'icon.jpg',
            resources_path / 'icon.jpeg',
            resources_path / 'logo.png',
            resources_path / 'logo.jpg',
            resources_path / 'logo.jpeg',
            resources_path / 'icon-only.png',
            resources_path / 'icon-only.jpg',
        ]
        banner_candidates = [
            resources_path / 'banner.png',
            resources_path / 'banner.jpg',
            resources_path / 'banner.jpeg',
        ]

    if icon_path:
        chosen_icon = Path(icon_path).expanduser().resolve()
    else:
        chosen_icon = next((c for c in icon_candidates if c.exists()), None)

    if banner_path:
        chosen_banner = Path(banner_path).expanduser().resolve()
    else:
        chosen_banner = next((c for c in banner_candidates if c.exists()), None)

    square_targets = {
        'LockScreenLogo.png': (24, 24),
        'Square44x44Logo.png': (44, 44),
        'Square150x150Logo.png': (150, 150),
        'StoreLogo.png': (50, 50),
    }
    banner_targets = {
        'SplashScreen.png': (620, 300),
        'Wide310x150Logo.png': (310, 150),
    }

    if chosen_icon and chosen_icon.exists():
        try:
            with Image.open(chosen_icon) as img:
                w, h = img.size
            if w == h:
                _info(f"ðŸ–¼  Resizing square icon: {chosen_icon}")
                for name, fallback in square_targets.items():
                    dest = images_dir / name
                    size = _get_target_size(dest, fallback)
                    with Image.open(chosen_icon) as img:
                        resized = img.resize(size, Image.Resampling.LANCZOS)
                        resized.save(dest)
                _success("âœ… Icons updated.")
            else:
                _warn("âš ï¸  Icon is not square; skipping icon updates.")
        except Exception as exc:
            _error(f"âŒ Error processing icon: {exc}")
    else:
        _warn("âš ï¸  No icon found; skipping icon updates.")

    if chosen_banner and chosen_banner.exists():
        try:
            with Image.open(chosen_banner) as img:
                w, h = img.size
            if _is_valid_aspect_ratio(w, h):
                ratio = w / h
                _info(f"ðŸ–¼  Resizing banner (ratio {ratio:.2f}): {chosen_banner}")
                for name, fallback in banner_targets.items():
                    dest = images_dir / name
                    size = _get_target_size(dest, fallback)
                    with Image.open(chosen_banner) as img:
                        resized = img.resize(size, Image.Resampling.LANCZOS)
                        resized.save(dest)
                _success("âœ… Banners updated.")
            else:
                ratio = w / h
                _warn(f"âš ï¸  Banner ratio {ratio:.2f} is outside 1.6â€“2.4; skipping banner updates.")
        except Exception as exc:
            _error(f"âŒ Error processing banner: {exc}")
    else:
        _warn("âš ï¸  No banner found; skipping banner updates.")

def edit_project_config(config_path: Path) -> None:
    data = _load_config(config_path)
    project_dir = _resolve_project_dir(config_path, data)
    if not project_dir.exists():
        _warn(f"âš ï¸  Project directory not found: {project_dir}")

    _info("ðŸ›   Project editor")
    name = data.get('name', project_dir.name)
    arch = data.get('arch', 'x64')
    publisher = data.get('publisher', 'CN=Unknown')
    resources_dir = data.get('resourcesDir', '')
    images = data.get('images', {}) or {}
    icon_path = images.get('icon', '')
    banner_path = images.get('banner', '')
    include_msvc_dlls = bool(data.get('includeMsvcDlls', False))
    manifest_paths = _get_manifest_paths(project_dir)
    current_caps = set()
    if manifest_paths:
        current_caps = _read_manifest_capabilities(manifest_paths[0])

    arch = _prompt_choice("Architecture", arch, ARCH_CHOICES)
    publisher = _prompt("Publisher (CN=...)", publisher)
    resources_dir = _prompt("Resources directory", resources_dir)
    icon_path = _prompt("Icon image path (optional)", icon_path)
    banner_path = _prompt("Banner image path (optional)", banner_path)
    include_msvc = _prompt("Include MSVC DLLs (yes/no)", "yes" if include_msvc_dlls else "no").lower() in ("y", "yes", "true", "1")
    selected_caps = _prompt_capabilities(current_caps)

    data['name'] = name
    data['arch'] = arch
    data['publisher'] = publisher
    data['resourcesDir'] = resources_dir
    data['projectDir'] = str(project_dir)
    data['images'] = {
        'icon': icon_path,
        'banner': banner_path
    }
    data['capabilities'] = sorted(selected_caps)
    data['includeMsvcDlls'] = include_msvc

    _save_config(config_path, data)
    _update_metadata(project_dir, arch)
    _update_manifest_publisher(project_dir, publisher)
    if manifest_paths:
        _update_manifest_capabilities(project_dir, selected_caps)
    _sync_images(project_dir, resources_dir, icon_path, banner_path)
    if include_msvc and project_dir.exists():
        _ensure_deps_layout(project_dir)
        _copy_msvc_dlls(project_dir, arch)
    _success(f"âœ… Updated config: {config_path}")

def launch_gui(default_template_dir: Path, default_output_dir: Path, default_arch: str, default_publisher: str, images_dir: Path):
    try:
        import tkinter as tk
        from tkinter import ttk, filedialog, messagebox
    except Exception as exc:
        print(f"Failed to start GUI: {exc}")
        sys.exit(1)

    root = tk.Tk()
    root.title("MinGW UWP Project Generator")
    root.geometry("640x450")
    root.resizable(False, False)

    header = ttk.Label(root, text="Create a new MinGW UWP project", font=("Segoe UI", 14, "bold"))
    header.pack(pady=(16, 6))
    subtitle = ttk.Label(root, text="Choose a template and project settings.")
    subtitle.pack(pady=(0, 10))

    frame = ttk.Frame(root, padding=16)
    frame.pack(fill=tk.BOTH, expand=True)

    def add_row(row, label_text, widget, button=None):
        label = ttk.Label(frame, text=label_text)
        label.grid(row=row, column=0, sticky="w", pady=6)
        widget.grid(row=row, column=1, sticky="ew", padx=(8, 0), pady=6)
        if button is not None:
            button.grid(row=row, column=2, sticky="e", padx=(8, 0), pady=6)

    frame.columnconfigure(1, weight=1)

    project_type_var = tk.StringVar(value="xaml")
    project_type = ttk.Combobox(frame, textvariable=project_type_var, state="readonly")
    project_type["values"] = ("library", "console", "xaml", "corewindow")

    name_var = tk.StringVar(value="MyApp")
    name_entry = ttk.Entry(frame, textvariable=name_var)

    output_var = tk.StringVar(value=str(default_output_dir))
    output_entry = ttk.Entry(frame, textvariable=output_var)
    output_button = ttk.Button(frame, text="Browse", command=lambda: output_var.set(filedialog.askdirectory() or output_var.get()))

    template_var = tk.StringVar(value=str(default_template_dir))
    template_entry = ttk.Entry(frame, textvariable=template_var)
    template_button = ttk.Button(frame, text="Browse", command=lambda: template_var.set(filedialog.askdirectory() or template_var.get()))

    arch_var = tk.StringVar(value=default_arch)
    arch_combo = ttk.Combobox(frame, textvariable=arch_var, state="readonly")
    arch_combo["values"] = ("x64", "x86", "arm64", "arm")

    publisher_var = tk.StringVar(value=default_publisher)
    publisher_entry = ttk.Entry(frame, textvariable=publisher_var)

    overwrite_var = tk.BooleanVar(value=False)
    overwrite_check = ttk.Checkbutton(frame, text="Overwrite output directory if it exists", variable=overwrite_var)

    include_msvc_var = tk.BooleanVar(value=False)
    include_msvc_check = ttk.Checkbutton(frame, text="Include MSVC DLLs in deps/bin", variable=include_msvc_var)

    add_row(0, "Project type", project_type)
    add_row(1, "Project name", name_entry)
    add_row(2, "Output directory", output_entry, output_button)
    add_row(3, "Template directory", template_entry, template_button)
    add_row(4, "Architecture", arch_combo)
    add_row(5, "Publisher", publisher_entry)
    overwrite_check.grid(row=6, column=1, sticky="w", pady=(10, 6))
    include_msvc_check.grid(row=7, column=1, sticky="w", pady=(0, 6))

    button_frame = ttk.Frame(root, padding=(16, 0, 16, 16))
    button_frame.pack(fill=tk.X)
    button_frame.columnconfigure(0, weight=1)

    def on_create():
        project_name = name_var.get().strip()
        if not project_name:
            messagebox.showerror("Missing name", "Project name is required.")
            return

        out_dir = Path(output_var.get()).expanduser().resolve() / project_name
        template_dir = Path(template_var.get()).expanduser().resolve()

        try:
            generate_project(
                template_dir=template_dir,
                project_type=project_type_var.get(),
                project_name=project_name,
                out_dir=out_dir,
                arch=arch_var.get(),
                publisher=publisher_var.get().strip() or default_publisher,
                reuse_images=images_dir,
                overwrite=overwrite_var.get(),
                include_msvc_dlls=include_msvc_var.get(),
            )
        except Exception as exc:
            messagebox.showerror("Generation failed", str(exc))
            return

        messagebox.showinfo("Project created", f"Project created at:\n{out_dir}")
        root.destroy()

    ttk.Button(button_frame, text="Create Project", command=on_create).grid(row=0, column=1, sticky="e")
    ttk.Button(button_frame, text="Cancel", command=root.destroy).grid(row=0, column=2, sticky="e", padx=(8, 0))

    root.mainloop()

def edit_project_config_gui(config_path: Path) -> None:
    data = _load_config(config_path)
    project_dir = _resolve_project_dir(config_path, data)
    manifest_paths = _get_manifest_paths(project_dir)
    current_caps = set()
    if manifest_paths:
        current_caps = _read_manifest_capabilities(manifest_paths[0])

    try:
        import tkinter as tk
        from tkinter import ttk, filedialog, messagebox
    except Exception as exc:
        _error(f"Failed to start GUI: {exc}")
        sys.exit(1)

    root = tk.Tk()
    root.title("MinGW WinRT Project Editor")
    root.geometry("800x760")
    root.resizable(True, True)

    header = ttk.Label(root, text="Edit MinGW WinRT project", font=("Segoe UI", 14, "bold"))
    header.pack(pady=(16, 6))
    subtitle = ttk.Label(root, text=str(config_path))
    subtitle.pack(pady=(0, 10))

    canvas = tk.Canvas(root, highlightthickness=0)
    scrollbar = ttk.Scrollbar(root, orient=tk.VERTICAL, command=canvas.yview)
    canvas.configure(yscrollcommand=scrollbar.set)

    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
    canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

    frame = ttk.Frame(canvas, padding=16)
    frame_id = canvas.create_window((0, 0), window=frame, anchor="nw")

    def _on_frame_configure(event):
        canvas.configure(scrollregion=canvas.bbox("all"))

    def _on_canvas_configure(event):
        canvas.itemconfig(frame_id, width=event.width)

    frame.bind("<Configure>", _on_frame_configure)
    canvas.bind("<Configure>", _on_canvas_configure)

    def add_row(row, label_text, widget, button=None):
        label = ttk.Label(frame, text=label_text)
        label.grid(row=row, column=0, sticky="w", pady=6)
        widget.grid(row=row, column=1, sticky="ew", padx=(8, 0), pady=6)
        if button is not None:
            button.grid(row=row, column=2, sticky="e", padx=(8, 0), pady=6)

    frame.columnconfigure(1, weight=1)

    name_var = tk.StringVar(value=data.get('name', project_dir.name))
    name_entry = ttk.Entry(frame, textvariable=name_var, state="disabled")

    project_dir_var = tk.StringVar(value=str(project_dir))
    project_dir_entry = ttk.Entry(frame, textvariable=project_dir_var, state="disabled")

    arch_var = tk.StringVar(value=data.get('arch', 'x64'))
    arch_combo = ttk.Combobox(frame, textvariable=arch_var, state="readonly")
    arch_combo["values"] = ARCH_CHOICES

    publisher_var = tk.StringVar(value=data.get('publisher', 'CN=Unknown'))
    publisher_entry = ttk.Entry(frame, textvariable=publisher_var)

    resources_var = tk.StringVar(value=data.get('resourcesDir', ''))
    resources_entry = ttk.Entry(frame, textvariable=resources_var)
    resources_button = ttk.Button(frame, text="Browse", command=lambda: resources_var.set(filedialog.askdirectory() or resources_var.get()))

    images = data.get('images', {}) or {}
    icon_var = tk.StringVar(value=images.get('icon', ''))
    icon_entry = ttk.Entry(frame, textvariable=icon_var)
    icon_button = ttk.Button(frame, text="Browse", command=lambda: icon_var.set(filedialog.askopenfilename() or icon_var.get()))

    banner_var = tk.StringVar(value=images.get('banner', ''))
    banner_entry = ttk.Entry(frame, textvariable=banner_var)
    banner_button = ttk.Button(frame, text="Browse", command=lambda: banner_var.set(filedialog.askopenfilename() or banner_var.get()))

    include_msvc_var = tk.BooleanVar(value=bool(data.get('includeMsvcDlls', False)))

    add_row(0, "Project name", name_entry)
    add_row(1, "Project directory", project_dir_entry)
    add_row(2, "Architecture", arch_combo)
    add_row(3, "Publisher", publisher_entry)
    add_row(4, "Resources directory", resources_entry, resources_button)
    add_row(5, "Icon image", icon_entry, icon_button)
    add_row(6, "Banner image", banner_entry, banner_button)
    ttk.Checkbutton(frame, text="Include MSVC DLLs in deps/bin", variable=include_msvc_var).grid(row=7, column=1, sticky="w", pady=(4, 6))

    cap_frame = ttk.Labelframe(frame, text="Capabilities", padding=12)
    cap_frame.grid(row=8, column=0, columnspan=3, sticky="ew", pady=(10, 6))
    cap_frame.columnconfigure(0, weight=1)
    cap_frame.columnconfigure(1, weight=1)

    cap_vars = {}
    caps_list = list(STANDARD_CAPS) + list(RESTRICTED_CAPS)
    for idx, cap in enumerate(caps_list):
        cap_vars[cap] = tk.BooleanVar(value=cap in current_caps)
        row = idx // 2
        col = idx % 2
        ttk.Checkbutton(cap_frame, text=cap, variable=cap_vars[cap]).grid(row=row, column=col, sticky="w", padx=4, pady=2)

    optional_frame = ttk.Labelframe(frame, text="Optional capabilities", padding=12)
    optional_frame.grid(row=9, column=0, columnspan=3, sticky="ew", pady=(6, 6))
    optional_frame.columnconfigure(1, weight=1)

    optional_selected = [cap for cap in OPTIONAL_CAPS if cap in current_caps]
    optional_var = tk.StringVar(value=OPTIONAL_CAPS[0] if OPTIONAL_CAPS else '')
    optional_combo = ttk.Combobox(optional_frame, textvariable=optional_var, state="readonly")
    optional_combo["values"] = OPTIONAL_CAPS

    optional_list = tk.Listbox(optional_frame, height=4)
    for cap in optional_selected:
        optional_list.insert(tk.END, cap)

    def add_optional():
        cap = optional_var.get()
        if not cap:
            return
        items = set(optional_list.get(0, tk.END))
        if cap not in items:
            optional_list.insert(tk.END, cap)

    def remove_optional():
        selection = optional_list.curselection()
        if not selection:
            return
        for idx in reversed(selection):
            optional_list.delete(idx)

    ttk.Label(optional_frame, text="Add capability").grid(row=0, column=0, sticky="w", pady=4)
    optional_combo.grid(row=0, column=1, sticky="ew", padx=(8, 0), pady=4)
    ttk.Button(optional_frame, text="Add", command=add_optional).grid(row=0, column=2, sticky="e", padx=(8, 0), pady=4)
    ttk.Label(optional_frame, text="Selected").grid(row=1, column=0, sticky="nw", pady=4)
    optional_list.grid(row=1, column=1, sticky="ew", padx=(8, 0), pady=4)
    ttk.Button(optional_frame, text="Remove", command=remove_optional).grid(row=1, column=2, sticky="ne", padx=(8, 0), pady=4)

    button_frame = ttk.Frame(root, padding=(16, 0, 16, 16))
    button_frame.pack(fill=tk.X)
    button_frame.columnconfigure(0, weight=1)

    def on_save():
        updated = dict(data)
        updated['name'] = name_var.get()
        updated['arch'] = arch_var.get()
        updated['publisher'] = publisher_var.get().strip() or 'CN=Unknown'
        updated['resourcesDir'] = resources_var.get().strip()
        updated['projectDir'] = project_dir_var.get()
        updated['images'] = {
            'icon': icon_var.get().strip(),
            'banner': banner_var.get().strip()
        }
        updated['includeMsvcDlls'] = bool(include_msvc_var.get())

        selected_caps = {cap for cap, var in cap_vars.items() if var.get()}
        selected_caps.update(optional_list.get(0, tk.END))
        updated['capabilities'] = sorted(selected_caps)

        _save_config(config_path, updated)
        _update_metadata(project_dir, updated['arch'])
        _update_manifest_publisher(project_dir, updated['publisher'])
        if manifest_paths:
            _update_manifest_capabilities(project_dir, set(selected_caps))
        _sync_images(project_dir, updated['resourcesDir'], updated['images']['icon'], updated['images']['banner'])
        if updated['includeMsvcDlls'] and project_dir.exists():
            _ensure_deps_layout(project_dir)
            _copy_msvc_dlls(project_dir, updated['arch'])

        messagebox.showinfo("Saved", f"Updated config: {config_path}")
        root.destroy()

    ttk.Button(button_frame, text="Save", command=on_save).grid(row=0, column=1, sticky="e")
    ttk.Button(button_frame, text="Cancel", command=root.destroy).grid(row=0, column=2, sticky="e", padx=(8, 0))

    root.mainloop()

def main():
    parser = argparse.ArgumentParser(description='Generate MinGW UWP projects (loose files)')
    parser.add_argument('type', choices=['library', 'console', 'xaml', 'corewindow'], help='Project type')
    parser.add_argument('name', help='Project name')
    parser.add_argument('--template-dir', default=str(Path(__file__).parent.parent / 'templates'), help='Templates directory')
    parser.add_argument('--output-dir', default='.', help='Output directory (will create a folder with project name)')
    parser.add_argument('--arch', default='x64', help='Target architecture (x64/x86/arm64/arm)')
    parser.add_argument('--publisher', default='CN=Unknown', help='Publisher CN for manifest')
    parser.add_argument('--overwrite', action='store_true', help='Overwrite output directory if it exists')
    parser.add_argument('--include-msvc-dlls', action='store_true', help='Copy MSVC runtime DLLs into deps/bin')

    force_cli = '--cli' in sys.argv
    if force_cli:
        sys.argv.remove('--cli')
    if '--gui' in sys.argv:
        sys.argv.remove('--gui')

    if len(sys.argv) == 1:
        repo_root = Path(__file__).parent.parent
        images_dir = repo_root / 'Images'
        launch_gui(
            default_template_dir=Path(parser.get_default('template_dir')).expanduser().resolve(),
            default_output_dir=Path(parser.get_default('output_dir')).expanduser().resolve(),
            default_arch=parser.get_default('arch'),
            default_publisher=parser.get_default('publisher'),
            images_dir=images_dir,
        )
        return

    json_args = [arg for arg in sys.argv[1:] if arg.lower().endswith('.json')]
    if json_args:
        maybe_config = Path(json_args[0])
        if maybe_config.exists():
            if force_cli:
                edit_project_config(maybe_config.resolve())
            else:
                edit_project_config_gui(maybe_config.resolve())
            return

    args = parser.parse_args()

    repo_root = Path(__file__).parent.parent
    template_dir = Path(args.template_dir)
    out_dir = Path(args.output_dir).resolve() / args.name
    images_dir = repo_root / 'Images'

    generate_project(template_dir, args.type, args.name, out_dir, args.arch, args.publisher, images_dir, args.overwrite, args.include_msvc_dlls)

if __name__ == '__main__':
    main()
